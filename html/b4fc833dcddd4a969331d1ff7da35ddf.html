<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="priority" content="normal">
    <meta name="description" content="力扣hot100题集，所有个人题解汇总。">
    <meta name="keywords" content="力扣, 算法, 面试, 字节, hot100, 刷题, 题解">
    <meta name="author" content="橙子">
    <title>HOT100 题解汇总</title>
    <link rel="stylesheet" href="../css/article.css">
    <link rel="stylesheet" href="../css/beian.css">
    <link rel="icon" href="../images/favicon.ico" type="image/x-icon">
</head>

<body>
    <header>
        <h1>HOT100 题解汇总</h1>
    </header>
    <main>
        <nav>
            <h2>目录</h2>
            <ul>
                <li><a href="#两数之和">两数之和</a></li>
                <li><a href="#字母异位词分组">字母异位词分组</a></li>
                <li><a href="#最长连续序列">最长连续序列</a></li>
                <li><a href="#移动零">移动零</a></li>
                <li><a href="#盛最多水的容器">盛最多水的容器</a></li>
                <li><a href="#三数之和">三数之和</a></li>
                <li><a href="#接雨水">接雨水</a></li>
                <li><a href="#无重复字符的最长子串">无重复字符的最长子串</a></li>
                <li><a href="#找到字符串中所有字母异位词">找到字符串中所有字母异位词</a></li>
                <li><a href="#和为k的子数组">和为k的子数组</a></li>
                <li><a href="#滑动窗口最大值">滑动窗口最大值</a></li>
                <li><a href="#最小覆盖子串">最小覆盖子串</a></li>
                <li><a href="#最大子数组和">最大子数组和</a></li>
                <li><a href="#合并区间">合并区间</a></li>
                <li><a href="#轮转数组">轮转数组</a></li>
                <li><a href="#除自身以外数组的乘积">除自身以外数组的乘积</a></li>
            </ul>
        </nav>
        <p class="article-intro">声明：本文题解所有代码都是本人编写，但由于本人能力有限，故解题思路大多参考和阅读他人文档，如果本文有侵权行为，请及时联系我删除。</p>
        <p class="article-intro">特别感谢labuladong(东哥)，本文很多思路都是参考他的文档，如果想要了解更多，请访问<a href="https://labuladong.online/algo"
                target="_blank" rel="noreferrer">labuladong的算法笔记</a>。</p>
        <p class="article-intro">本文汇总了本人刷hot100的所有题解和心得包括源代码。</p>
        <p class="article-intro">本文会持续更新，直到刷完hot100。</p>
        <section id="两数之和">
            <h1>两数之和</h1>
            <p><a href="https://leetcode.cn/problems/two-sum/" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题还是很简单的，有多种解法。</p>
            <p>解法：</p>
            <ol>
                <li>暴力解法，两层for循环，时间复杂度O(n^2)，空间复杂度O(1)</li>
                <li>哈希表，时间复杂度O(n)，空间复杂度O(n)</li>
                <li>双指针，时间复杂度O(nlogn)，空间复杂度O(1)</li>
            </ol>
            <p>针对这道题，我们可以知道，如果答案存在，那么一定会是某两个数的和，于是我们只需要针对每一个数nums[i]，都尝试在整个数组中寻找target-nums[i]，如果找到了，那么就返回这两个数的索引。</p>
            <p>于是问题就变成了，如何快速查找target-nums[i]。</p>
            <p>最直接的想法就是针对每一个数都遍历一遍数组（注意需要跳过自己），但是这样时间复杂度是O(n^2)，显然不合适。</p>
            <p>于是我们想到了哈希表，哈希表的查找时间复杂度是O(1)，所以我们可以将数组中的每一个数都存入哈希表中，然后针对每一个数nums[i]，都查找哈希表中是否存在target-nums[i]，如果存在，那么就返回这两个数的索引。
            </p>
            <p>但是我们如何在哈希表做法中跳过当前已经选择的元素呢？</p>
            <p>答案是，我们可以以每个元素为key其索引为value，每次找到了target-nums[i]的时候就检查一下索引是否和当前选择的元素的索引相同即可。这样也方便返回索引。</p>
            <p>如果你不想这么麻烦的排除重复使用一个元素的情况，那么就可以使用双指针做法。</p>
            <p>双指针做法的思路是，首先将数组排序，然后使用两个指针，一个指向数组的开头，一个指向数组的末尾，然后每次比较两个指针指向的元素的和是否等于target，如果等于，那么就返回这两个元素的索引，如果小于target，那么就移动左指针，如果大于target，那么就移动右指针。
            </p>
            <p>但是这样返回的索引是排序后的索引，而不是原数组的索引，所以需要再遍历一遍数组，找到原数组的索引。</p>
            <p>双指针做法的时间复杂度是O(nlogn)，空间复杂度是O(1)。</p>
            <p>这里给出哈希表解法的Go代码：</p>
            <pre><code>
func twoSum(nums []int, target int) []int {
    mapIndex := make(map[int]int)
    for i, v := range nums {
        mapIndex[v] = i
    }
    ans := make([]int, 2)
    for i, num := range nums {
        if anst, ok := mapIndex[target-num]; ok {
            if anst == i {
                continue
            }
            ans[0] = anst
            ans[1] = i
            break
        }
    }
    return ans
}

            </code></pre>
        </section>
        <section id="字母异位词分组">
            <h1>字母异位词分组</h1>
            <p><a href="https://leetcode.cn/problems/group-anagrams/" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>首先搞明白什么是字母异位词：字母异位词是指两个字符串，它们包含的字母相同，但是字母的顺序不同。</p>
            <p>那么如何判断两个词是字母异味词？很简单，排序！字母异位词排序后是相同的。</p>
            <p>于是这道题的思路就很清晰了，我们只需要将每个字符串排序后，然后存入哈希表中，如果哈希表中已经存在这个排序后的字符串，那么就说明这两个字符串是字母异味词，然后将这两个字符串存入同一个列表中。</p>
            <p>最后返回哈希表中的所有列表即可。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
import (
    "sort"
)

func groupAnagrams(strs []string) [][]string {
    var mapp map[string][]string
    mapp = make(map[string][]string)
    for _, str := range strs {
        chars := []rune(str)
        sort.Slice(chars, func(i, j int) bool {
            return chars[i] < chars[j]
        })
        strTemp := string(chars)
        mapp[strTemp] = append(mapp[strTemp], str)
    }
    var ans [][]string
    for _, val := range mapp {
        ans = append(ans, val)
    }
    return ans
}
            </code></pre>
        </section>
        <section id="最长连续序列">
            <h1>最长连续序列</h1>
            <p><a href="https://leetcode.cn/problems/longest-consecutive-sequence" target="_blank"
                    rel="noreferrer">题目链接</a></p>
            <p>这道题不难，但是它要求在O(n)来实现，所以我就不能简单的排序后遍历一遍，那样时间复杂度是O(nlogn)。</p>
            <p>所以思考，如何判断一个数是连续序列的一部分？很简单，如果它-1或者+1在数组中，那么它就是连续序列的一部分。</p>
            <p>于是我们可以使用一个哈希表来存储数组中的每一个数，然后遍历数组，对于每一个数，我们都检查它-1和+1是否在哈希表中，如果在，那么就说明这个数是连续序列的一部分。</p>
            <p>但是，说到这里，也只说了基础思路，在此基础上如何获得最长序列长度？</p>
            <p>想要获得最长序列长度，就要知道有序的序列起始位置在哪，起始位置有什么特点呢？那就是它-1不在数组中。</p>
            <p>所以，我们可以遍历数组，对于每一个数，我们都检查它-1是否在哈希表中，如果不在，那么就说明这个数是连续序列的起始位置。</p>
            <p>进一步我们可以从起始位置开始，向右遍历，直到遇到一个数+1不在哈希表中，那么就说明这个数是连续序列的结束位置。</p>
            <p>然后，我们就可以更新最长序列长度。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func longestConsecutive(nums []int) int {
    set := make(map[int]struct{})
    for _, num := range nums {
        set[num] = struct{}{}
    }
    ans := 0

    for num := range set {
        if _, ok := set[num-1]; ok {
            continue
        }
        ansTmp := 1
        for {
            if _, ok := set[num+1]; ok {
                num++
                ansTmp++
            } else {
                break
            }
        }
        if ansTmp > ans {
            ans = ansTmp
        }
    }
    return ans
}
            </code></pre>
            <p>这段代码中有一个需要注意的地方，那就是必须要遍历哈希表，而不是遍历数组，因为数组中可能存在重复的元素，而哈希表中不存在重复的元素，这样就可以避免重复计算，否则你会有一个测试用例过不去。</p>
        </section>
        <section id="移动零">
            <h1>移动零</h1>
            <p><a href="https://leetcode.cn/problems/move-zeroes" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题也很简单，题目要求将数组中的0移动到数组的末尾，同时保持非零元素的相对顺序。</p>
            <p>唯一需要注意的点是要保持顺序，并且不能新开数组。</p>
            <p>显而易见的一个思路：遍历数组，直到遇到0，从当前节点向后遍历数组，找到第一个非零元素，然后交换这两个元素。</p>
            <p>但是这样的时间复杂度有点高。因为你每次都遍历数组，时间复杂度是O(n^2)。</p>
            <p>于是我们可以用双指针来优化。i指向第一个为0的位置，j指向从i开始第一个非零元素的位置。</p>
            <p>先移动i，直到遇到0，然后移动j，满足j&gti&&nums[j]!=0&&j&ltlen(nums)，然后交换nums[i]和nums[j]。</p>
            <p>由于j保存了上次找到的非零元素的位置，所以j不需要每次都从i开始遍历，只需要从j开始寻找即可，所以时间消耗会少。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func moveZeroes(nums []int) {
    i, j := 0, 0
    for i < len(nums) {
        if nums[i] == 0 {
            for j < len(nums) && (j < i || nums[j] == 0) {
                j++
            }
            if j < len(nums) {
                nums[i], nums[j] = nums[j], nums[i]
            }
        }
        i++
    }
}
            </code></pre>
        </section>
        <section id="盛最多水的容器">
            <h1>盛最多水的容器</h1>
            <p><a href="https://leetcode.cn/problems/container-with-most-water" target="_blank"
                    rel="noreferrer">题目链接</a>
            </p>
            <p>这道题的目的是找到两个线段之间可以容纳的最大水量。给定一个长度为n的数组height，height[i]表示第i个线段的高度。我们可以想象成每个线段都是一个容器壁，线段之间可以容纳水。我们的目标是找到两个线段之间可以容纳的最大水量。
            </p>
            <p>这个问题的关键是如何找到这两个线段。我们可以使用双指针的方法，从两端开始向中间移动，计算每次移动时的水量，并记录最大水量。移动的策略是，如果左边的线段高度小于右边的线段高度，则移动左边的指针，反之移动右边的指针。这样可以确保每次移动都有可能找到更大的水量。
            </p>
            <p>你可能会疑惑为什么每次要移动小的那个线段指针？你可以想一下，每次的盛水容量都是由宽度和最小的线段决定的，所以如果移动大的那个线段指针，那么宽度就会减小，而最小线段的高度不会变，也就是说高度不可能变高，只可能变小，而宽度也一定减小，所以如果移动高的线段，结果一定更差。
            </p>
            <p>而如果移动的是较小的那个线段，虽然结果不一定会变大，但是至少有概率变大。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func maxArea(height []int) int {
    i, j := 0, len(height)-1
    ans := 0
    for i < j {
        width := j - i
        high := min(height[i], height[j])
        if width*high > ans {
            ans = width * high
        }
        if height[i] == high {
            i++
        } else {
            j--
        }
    }
    return ans
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
            </code></pre>
        </section>
        <section id="三数之和">
            <h1>三数之和</h1>
            <p><a href="https://leetcode.cn/problems/3sum" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题其实是二数之和的拓展。</p>
            <p>实际上这道题的做法受东哥(labuladong)启发，其思路其实是先排序，对于每一个数，都尝试在后面的数组中寻找和为0-nums[i]的二数之和，如果找到了，那么就返回这三个数。</p>
            <p>思路很简单，但是这道题的难点在于去重。本题有多个答案，并且数组中会有重复元素，所以需要在之前的二数之和的基础上进行更新：由于我们这次返回的是数字而非索引，所以我们可以大胆的使用双指针做法，并且双指针更利于去重。具体思路是，在排序好的数组中左右两个指针向中间移动，如果遇到重复元素，那么就跳过。这样就可以保证在二数和部分不会有重复内容。
            </p>
            <p>但是在三数和中还是会重复，例如这个用例：[-1,0,1,2,-1,-4]，排序后是[-4,-1,-1,0,1,2]。当选择的第一个数是-1的时候，去找和为1的二数和，得到的结果是[2,-1]和[0,1]，最终结果就是[-1,2,-1]和[-1,0,1]，但是如果后面我们选择到了2的话还是会得到[-1,2,-1]这个结果。这就重复了。
            </p>
            <p>如何解决这种重复呢？答案很简单每次找二数和的时候都只考虑当前数字后面的数组，这是因为如果整个流程按照之前的思路考虑剩下的所有数组的话，那么在选择-1的时候会考虑2，在选择2的时候会考虑-1，而2和-1同时出现的情况之前选择-1的时候就考虑过了，这就会导致重复。为了避免这种重复，我们就从当前数字的后面开始找二数和。
            </p>
            <p>这里给出Go代码：</p>
            <pre><code>
func threeSum(nums []int) [][]int {
    sort.Slice(nums, func(i, j int) bool {
        return nums[i] < nums[j]
    })
    fmt.Println(nums)
    ans := make([][]int, 0)
    for i := 0; i < len(nums); {
        numstmp := make([]int, len(nums))
        copy(numstmp, nums)
        anstwo := twoSum(numstmp[i+1:], 0-nums[i])
        for _, s := range anstwo {
            anstmp := make([]int, 3)
            anstmp[0] = nums[i]
            anstmp[1] = s[0]
            anstmp[2] = s[1]
            ans = append(ans, anstmp)
        }
        numtmp := nums[i]
        for i < len(nums) && nums[i] == numtmp {
            i++
        }
    }
    return ans
}

func twoSum(nums []int, target int) [][]int {
    ans := make([][]int, 0)
    i, j := 0, len(nums)-1
    for i < j {
        tmp := nums[i] + nums[j]
        if tmp < target {
            tmpi := nums[i]
            for i < len(nums) && nums[i] == tmpi {
                i++
            }
        } else if tmp > target {
            tmpj := nums[j]
            for j > 0 && nums[j] == tmpj {
                j--
            }
        } else {
            ansTmp := make([]int, 2)
            ansTmp[0] = nums[i]
            ansTmp[1] = nums[j]
            tmpi := nums[i]
            for i < len(nums) && nums[i] == tmpi {
                i++
            }
            tmpj := nums[j]
            for j > 0 && nums[j] == tmpj {
                j--
            }
            ans = append(ans, ansTmp)
        }
    }
    return ans
}

            </code></pre>
        </section>
        <section id="接雨水">
            <h1>接雨水</h1>
            <p><a href="https://leetcode.cn/problems/trapping-rain-water" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题是经典的接雨水问题，题目要求计算一个数组中可以接到的雨水总量。</p>
            <p>首先，如果一个地方能解雨水，是不是意味着其两边有比它高的柱子？那么一个格子能接的最大雨水量是否就是其两边最高柱子中较矮的那个减去它的高度？</p>
            <p>答案是肯定的，所以我们暴力搜索，对于每一个格子，我们都计算它两边最高的柱子，然后计算它能够接到的雨水量。</p>
            <p>但是这样时间复杂度是O(n^2)，显然不合适。</p>
            <p>于是，其实可以用一个备忘录来记录每个格子左右最高的柱子，这样时间复杂度就变成了O(n)。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func trap(height []int) int {
    lMax := make([]int, len(height))
    rMax := make([]int, len(height))
    lMax[0] = height[0]
    rMax[len(height)-1] = height[len(height)-1]
    for i := 1; i < len(height); i++ {
        lMax[i] = max(height[i], lMax[i-1])
    }
    for i := len(height) - 2; i >= 0; i-- {
        rMax[i] = max(height[i], rMax[i+1])
    }
    ans := 0
    for i := 1; i < len(height)-1; i++ {
        ans += min(lMax[i], rMax[i]) - height[i]
    }
    return ans
}

func max(a, b int) int {
    if a < b {
        return b
    }
    return a
}

func min(a, b int) int {
    if a > b {
        return b
    }
    return a
}
            </code></pre>
        </section>
        <section id="无重复字符的最长子串">
            <h1>无重复字符的最长子串</h1>
            <p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters" target="_blank"
                    rel="noreferrer">题目链接</a></p>
            <p>这道题是经典的滑动窗口问题，题目要求找到一个字符串中无重复字符的最长子串。</p>
            <p>这道题的思路是，使用一个哈希表来记录每个字符出现的次数，然后使用两个指针，一个指向当前子串的开始，一个指向当前子串的结束。</p>
            <p>右指针不断向右移动，将新的字符加入哈希表，每加入一个字符，如果哈希表中该字符的值大于1，那么就说明出现了重复字符，此时需要移动左指针，直到哈希表中该字符的值为1为止。</p>
            <p>在移动左右指针的过程中，记录当前子串的长度，并更新最大长度。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func lengthOfLongestSubstring(s string) int {
    var max int
    var windows = make(map[byte]int)
    var left, right int
    for right < len(s) {
        c := s[right]
        right++
        windows[c]++
        for windows[c] > 1 {
            d := s[left]
            left++
            windows[d]--
        }
        if right-left > max {
            max = right - left
        }
    }
    return max
}
            </code></pre>
        </section>
        <section id="找到字符串中所有字母异位词">
            <h1>找到字符串中所有字母异位词</h1>
            <p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string" target="_blank"
                    rel="noreferrer">题目链接</a></p>
            <p>这道题也是滑动窗口问题，题目要求找到一个字符串中所有字母异位词。</p>
            <p>这道题的思路是，使用两个哈希表，一个记录目标字符串p中每个字符出现的次数，一个记录当前窗口中每个字符出现的次数。</p>
            <p>然后使用两个指针，一个指向当前窗口的开始，一个指向当前窗口的结束。</p>
            <p>右指针不断向右移动，将新的字符加入窗口哈希表，如果这个字符在目标字符串p中存在，那么就将其加入窗口哈希表，并且如果窗口哈希表中该字符的值等于目标哈希表中该字符的值，那么就说明这个字符已经满足要求，将val加1。
            </p>
            <p>当窗口大小大于目标字符串p的长度时，需要移动左指针，将左指针指向的字符从窗口哈希表中移除，如果这个字符在目标字符串p中存在，那么就需要将其从窗口哈希表中移除，并且如果窗口哈希表中该字符的值等于目标哈希表中该字符的值，那么就说明这个字符不再满足要求，将val减1。
            </p>
            <p>当窗口大小等于目标字符串p的长度，并且val等于目标哈希表的大小时，说明当前窗口中的字符串是目标字符串p的字母异位词，将左指针加入答案数组。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func findAnagrams(s string, p string) []int {
    if len(s) < len(p) {
        return nil
    }
    var needp = make(map[byte]int)
    for i := 0; i < len(p); i++ {
        needp[p[i]]++
    }
    ans := make([]int, 0, len(s))
    var window = make(map[byte]int)
    var left, right, val int
    for right < len(s) {
        nowChar := s[right]
        right++
        if needp[nowChar] > 0 {
            window[nowChar]++
            if window[nowChar] == needp[nowChar] {
                val++
            }
        }
        for right-left > len(p) {
            nowChar := s[left]
            left++
            if needp[nowChar] > 0 {
                if window[nowChar] == needp[nowChar] {
                    val--
                }
                window[nowChar]--
            }
        }
        if len(p) == right-left && val == len(needp) {
            ans = append(ans, left)
        }
    }
    return ans
}
            </code></pre>
        </section>
        <section id="和为k的子数组">
            <h1>和为k的子数组</h1>
            <p><a href="https://leetcode.cn/problems/subarray-sum-equals-k" target="_blank" rel="noreferrer">题目链接</a>
            </p>
            <p>这道题在本博客的前缀和详解文章中已经详细讲解过了，这里就不再赘述。有需要的可以访问<a href="./38d932e7111444f3a6c041196932d965.html"
                    target="_blank" rel="noreferrer">前缀和详解</a>。</p>
        </section>
        <section id="滑动窗口最大值">
            <h1>滑动窗口最大值</h1>
            <p><a href="https://leetcode.cn/problems/sliding-window-maximum" target="_blank" rel="noreferrer">题目链接</a>
            </p>
            <p>这道题看似是滑动窗口题目，但是却不能用滑动窗口来做。</p>
            <p>原因很简单，在当前最大值被移出窗口的时候，你如何找到下一个最大值？难道用遍历的吗？显然不行。</p>
            <p>另外一个让人比较容易想到的解法是大顶堆，也就是优先队列，但是这也是不行的，因为窗口移动的时候被移除的元素无法映射到大顶堆里，大顶堆只能出队最大的那个元素。</p>
            <p>所以其实这道题的正确解法是单调队列。</p>
            <p>单调队列和单调栈是相对应的数据结构，单调队列的队列是双端队列，要求可以从队尾出队。</p>
            <p>单调队列的思路是，每次有新元素入队的时候，如果新元素比队尾元素大，那么就从队尾出队，直到队尾元素比新元素大为止。</p>
            <p>这样就可以保证队列是单调递减的。</p>
            <p>对应到这道题，每次移动窗口要出队的时候，如果队首元素和窗口左边界相等，那么就出队。否则忽略。入队的时候则按照单调队列的规定入队。</p>
            <p>这样就可以保证队首始终是还在窗口内的最大值。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func maxSlidingWindow(nums []int, k int) []int {
    i := 0
    j := k
    q := make([]int, 0)
    for l := i; l < j; l++ {
        for len(q) > 0 && q[len(q)-1] < nums[l] {
            q = q[:len(q)-1]
        }
        q = append(q, nums[l])
    }
    i++
    j++
    max := make([]int, 0)
    max = append(max, q[0])
    for j <= len(nums) {
        for len(q) > 0 && q[len(q)-1] < nums[j-1] {
            q = q[:len(q)-1]
        }
        q = append(q, nums[j-1])
        if q[0] == nums[i-1] {
            q = q[1:]
        }
        max = append(max, q[0])
        j++
        i++
    }
    return max
}
            </code></pre>
        </section>
        <section id="最小覆盖子串">
            <h1>最小覆盖子串</h1>
            <p><a href="https://leetcode.cn/problems/minimum-window-substring" target="_blank" rel="noreferrer">题目链接</a>
            </p>
            <p>这道题是滑动窗口问题，题目要求找到一个字符串中包含另一个字符串所有字符的最小子串。</p>
            <p>其实和<a href="#找到字符串中所有字母异位词" rel="noreferrer">找到字符串中所有字母异位词</a>思路是一样的，都是使用滑动窗口和哈希表来解决。</p>
            <p>用一个哈希表存储目标字符串t中每个字符出现的次数，用另一个哈希表存储当前窗口中每个字符出现的次数。</p>
            <p>然后使用两个指针，一个指向当前窗口的开始，一个指向当前窗口的结束。</p>
            <p>定义一个val变量来表示需要满足多少个字母的需求，当val==needval的时候说明找到了一个满足条件的子串。</p>
            <p>下面我们详细说一下滑动窗口的思路:</p>
            <p>何时移动右指针？<br>如果当前窗口内的值不能满足val==needval，那么就移动右指针，直到满足条件为止。</p>
            <p>何时移动左指针？<br>如果当前窗口内的值满足val==needval，那么就移动左指针，直到不满足条件为止。</p>
            <p>何时更新答案？<br>当val==needval的时候，并且左指针再移动一次就无法满足条件的时候，更新答案。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func minWindow(s string, t string) string {
    needMap := make(map[byte]int)
    sb := []byte(s)
    tb := []byte(t)
    needVal := 0
    for _, b := range tb {
        if _, ok := needMap[b]; !ok {
            needVal++
        }
        needMap[b]++
    }
    val := 0
    nowMap := make(map[byte]int)
    var ans string
    isAns := false
    i, j := 0, 1
    for j <= len(sb) {
        nowMap[sb[j-1]]++
        if need, ok := needMap[sb[j-1]]; ok && need == nowMap[sb[j-1]] {
            val++
        }
        for val == needVal {
            if need, ok := needMap[sb[i]]; ok && need == nowMap[sb[i]] {
                val--
                if j-i < len(ans) || !isAns {
                    ans = string(sb[i:j])
                    isAns = true
                }
            }
            nowMap[sb[i]]--
            i++
        }
        j++
    }
    return ans
}
            </code></pre>
        </section>
        <section id="最大子数组和">
            <h1>最大子数组和</h1>
            <p><a href="https://leetcode.cn/problems/maximum-subarray" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>我在<a href="./38d932e7111444f3a6c041196932d965.html" target="_blank"
                    rel="noreferrer">前缀和详解</a>中写到子数组问题大部分可以用三种算法解决：</p>
            <ol>
                <li>双指针</li>
                <li>前缀和+哈希表</li>
                <li>动态规划</li>
            </ol>
            <p>这道题是经典的动态规划问题，题目要求找到一个数组中最大的子数组和。</p>
            <p>解决动态规划问题，首先解决状态是什么。也就是dp数组是什么？</p>
            <p>一般的思维会认为dp[i]是前i个元素的最大子数组和，但是对于这道题，这样的解法是错误的，因为子数组必须连续，而“前i个元素的最大子数组和”并不一定包含第i个元素，那么如果此时通过状态转移方程，将第i+1个元素加入到dp[i]中，那么就无法保证子数组是连续的。
            </p>
            <p>那么dp[i]应该是什么呢？</p>
            <p>dp[i]应该是以第i个元素结尾的最大子数组和。</p>
            <p>那么状态转移方程是什么呢？</p>
            <p>dp[i] = max(dp[i-1]+nums[i], nums[i])</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func maxSubArray(nums []int) int {
    dp := make([]int, len(nums))
    dp[0] = nums[0]
    max := dp[0]
    for i := 1; i < len(nums); i++ {
        if dp[i-1] < 0 {
            dp[i] = nums[i]
        } else {
            dp[i] = nums[i] + dp[i-1]
        }
        if dp[i] > max {
            max = dp[i]
        }
    }
    return max
}
            </code></pre>
        </section>
        <section id="合并区间">
            <h1>合并区间</h1>
            <p><a href="https://leetcode.cn/problems/merge-intervals" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题没有什么算法，其实就是排序+模拟。</p>
            <p>首先将区间按照左节点排序，然后从第一个区间开始，判断当前区间的右节点和下一区间的左右节点的关系。</p>
            <ol>
                <li>当前右节点>=下一个区间的右节点：答案数组中直接跳过下一个区间即可。</li>
                <li>当前右节点&lt;下一个区间的右节点&&当前右节点&gt;=下一个区间的左节点：答案数组中将当前区间右节点更新为下一个区间右节点。</li>
                <li>当前右节点&lt;下一个区间的左节点：答案数组中将当前区间加入答案数组，然后更新当前区间为下一个区间。</li>
            </ol>
            <p>这里给出Go代码：</p>
            <pre><code>
import "sort"

func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    for i := 0; i < len(intervals)-1; {
        if intervals[i][1] >= intervals[i+1][1] {
            if i+2 < len(intervals) {
                intervals = append(intervals[:i+1], intervals[i+2:]...)
            } else {
                intervals = intervals[:len(intervals)-1]
            }
        } else if intervals[i][1] < intervals[i+1][1] && intervals[i][1] >= intervals[i+1][0] {
            intervals[i][1] = intervals[i+1][1]
            if i+2 < len(intervals) {
                intervals = append(intervals[:i+1], intervals[i+2:]...)
            } else {
                intervals = intervals[:len(intervals)-1]
            }
        } else {
            i++
        }
    }
    return intervals
}
            </code></pre>
            <p>熟悉Go语言的读者可以发现，这个代码的效率其实很低，因为大量使用append对切片进行删除，而Go语言中用append删除的时候其实是用后续数组覆盖前一个数组，所以很浪费时间。</p>
            <p>想详细了解Go语言特性的请移步<a href="./bf9c7b19ca5d47ddb10a5d7a7f095703.html" target="_blank"
                    rel="noreferrer">GoLang语言大揭秘</a>。</p>
            <p>这里用一个简单的示例向不熟悉Go语言的读者验证上述观点：</p>
            <pre><code>
package main

import (
    "fmt"
)

func main() {
    nums := []int{-1, -100, 3, 99}
    nums2 := append(nums[:1], nums[2:]...)
    fmt.Println(nums2)
    fmt.Println(nums)
}
            </code></pre>
            <p>输出为：</p>
            <pre><code>
[-1 3 99]
[-1 3 99 99]
            </code></pre>
            <p>可见append操作是浅拷贝，会和之前的被附加的数组共享同一个底层数组，并且其删除是覆盖删除，所以效率很低。</p>
            <p>所以这里给出优化后的代码：</p>
            <pre><code>
import "sort"

func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    res := make([][]int, 0)
    res = append(res, intervals[0])
    for i := 0; i < len(intervals); i++ {
        if res[len(res)-1][1] >= intervals[i][1] {
            continue
        } else if res[len(res)-1][1] >= intervals[i][0] && res[len(res)-1][1] < intervals[i][1] {
            res[len(res)-1][1] = intervals[i][1]
        } else {
            res = append(res, intervals[i])
        }
    }
    return res
}
            </code></pre>
            <p>这份代码使用了新的数组来存储答案，无需用append多次删除元素。</p>
        </section>
        <section id="轮转数组">
            <h1>轮转数组</h1>
            <p><a href="https://leetcode.cn/problems/rotate-array" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题是经典的数组轮转问题，题目要求将一个数组向右轮转k个位置。</p>
            <p>其实这道题一个不考虑空间复杂度的方法很简单，那就是先把k%n，然后用一个新数组存储当前数组，然后从n-k开始遍历，将新数组中的元素赋值到当前数组中。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func rotate(nums []int, k int) {
    k = k % len(nums)
    nums2 := make([]int, len(nums))
    copy(nums2, nums)
    i := len(nums) - k
    for j := 0; j < len(nums); j++ {
        nums[j] = nums2[i%len(nums)]
        i++
    }
}
            </code></pre>
            <p>奈何本人能力有限，实在没想出空间复杂度为O(1)的解法，故去查看了官方题解。</p>
            <p>实际上官方题解从数学的角度思考，对于当前数组中的nums[i]，其轮转后的位置其实是(i+k)%n，为了防止赋值后丢失位于(i+k)%n的元素，需要先保存这个元素，然后赋值，以此类推，最后总会回到nums[0]。
            </p>
            <p>但是实际上回到nums[0]的时候，整个数组中还可能有没有被遍历到的元素，所以可以用一个count存储已经遍历到的元素个数，当count==n的时候，说明整个数组已经遍历完毕，退出循环。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func rotate(nums []int, k int) {
    k = k % len(nums)
    j := 0
    count := 0
    for {
        if count == len(nums) {
            break
        }
        i := j
        tmp := nums[i]
        for {
            nums[(i+k)%len(nums)], tmp = tmp, nums[(i+k)%len(nums)]
            i = (i + k) % len(nums)
            count++
            if i == j {
                break
            }
        }
        j++
    }
}
            </code></pre>
        </section>
        <section id="除自身以外数组的乘积">
            <h1>除自身以外数组的乘积</h1>
            <p><a href="https://leetcode.cn/problems/product-of-array-except-self" target="_blank"
                    rel="noreferrer">题目链接</a></p>
            <p>这道题其实最直接的思路就是每一个都算一遍，但是这样时间复杂度是O(n^2)，显然不行。</p>
            <p>又因为这道题不让用除法，所以我们来想为什么直接的思路会很慢？答案是做了很多重复计算。</p>
            <p>那我们把重复的计算都用备忘录存下来不就好了吗？是的，这就前缀和的思想。对于这道题用到的其实是前缀乘和后缀乘。</p>
            <p>设pre[i]表示nums[0]到nums[i-1]的乘积，bef[i]表示nums[i+1]到nums[n-1]的乘积。</p>
            <p>那么答案数组ans[i]就是pre[i]*suf[i]。</p>
            <p>注意这道题无需给出整个数组的乘积，所以pre和bef数组只需要开n个元素。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func productExceptSelf(nums []int) []int {
    pre := make([]int, len(nums))
    beh := make([]int, len(nums))
    pre[0] = 1
    beh[len(beh)-1] = 1
    for i := 1; i < len(pre); i++ {
        pre[i] = pre[i-1] * nums[i-1]
    }
    for i := len(beh) - 2; i >= 0; i-- {
        beh[i] = beh[i+1] * nums[i+1]
    }
    ans := make([]int, len(nums))
    for i := 0; i < len(nums); i++ {
        ans[i] = pre[i] * beh[i]
    }
    return ans
}
            </code></pre>
        </section>
    </main>
    <footer class="beian-footer">
        <div class="beian-info">
            <img src="../images/备案图标.png" alt="备案图标" class="beian-icon">
            <a href="https://beian.mps.gov.cn/#/query/webSearch?code=42011102005555" rel="noreferrer"
                target="_blank">鄂公网安备 42011102005555 </a>
            <span class="spacer"> </span>
            <a href="https://beian.miit.gov.cn/#/Integrated/index" rel="noreferrer" target="_blank"
                class="icp-beian">青ICP备2024002362号-1 </a>
        </div>
    </footer>
    <footer class="last-edit">
        <p>最后编辑时间: 2025-01-20 13:52:21</p>
    </footer>
    <script src="../js/article.js"></script>
</body>

</html>