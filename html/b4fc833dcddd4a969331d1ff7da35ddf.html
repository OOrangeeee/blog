<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="priority" content="normal">
    <meta name="description" content="力扣hot100题集，所有个人题解汇总。">
    <meta name="keywords" content="力扣, 算法, 面试, 字节, hot100, 刷题, 题解">
    <meta name="author" content="橙子">
    <title>HOT100 题解汇总</title>
    <link rel="stylesheet" href="../css/article.css">
    <link rel="stylesheet" href="../css/beian.css">
    <link rel="icon" href="../images/favicon.ico" type="image/x-icon">
</head>

<body>
    <header>
        <h1>HOT100 题解汇总</h1>
    </header>
    <main>
        <nav>
            <h2>目录</h2>
            <ul>
                <li><a href="#两数之和">两数之和</a></li>
                <li><a href="#字母异位词分组">字母异位词分组</a></li>
                <li><a href="#最长连续序列">最长连续序列</a></li>
                <li><a href="#移动零">移动零</a></li>
                <li><a href="#盛最多水的容器">盛最多水的容器</a></li>
                <li><a href="#三数之和">三数之和</a></li>
                <li><a href="#接雨水">接雨水</a></li>
                <li><a href="#无重复字符的最长子串">无重复字符的最长子串</a></li>
                <li><a href="#找到字符串中所有字母异位词">找到字符串中所有字母异位词</a></li>
                <li><a href="#和为k的子数组">和为k的子数组</a></li>
                <li><a href="#滑动窗口最大值">滑动窗口最大值</a></li>
                <li><a href="#最小覆盖子串">最小覆盖子串</a></li>
                <li><a href="#最大子数组和">最大子数组和</a></li>
                <li><a href="#合并区间">合并区间</a></li>
                <li><a href="#轮转数组">轮转数组</a></li>
                <li><a href="#除自身以外数组的乘积">除自身以外数组的乘积</a></li>
                <li><a href="#缺失的第一个正整数">缺失的第一个正整数</a></li>
                <li><a href="#矩阵置零">矩阵置零</a></li>
                <li><a href="#螺旋矩阵">螺旋矩阵</a></li>
                <li><a href="#旋转图像">旋转图像</a></li>
                <li><a href="#搜索二维矩阵II">搜索二维矩阵II</a></li>
                <li><a href="#相交链表">相交链表</a></li>
                <li><a href="#反转链表">反转链表</a></li>
                <li><a href="#回文链表">回文链表</a></li>
                <li><a href="#环形链表">环形链表</a></li>
                <li><a href="#环形链表II">环形链表II</a></li>
                <li><a href="#合并两个有序链表">合并两个有序链表</a></li>
                <li><a href="#两数相加">两数相加</a></li>
                <li><a href="#删除链表的倒数第N个节点">删除链表的倒数第N个节点</a></li>
                <li><a href="#两两交换链表中的节点">两两交换链表中的节点</a></li>
                <li><a href="#K个一组翻转链表">K个一组翻转链表</a></li>
                <li><a href="#随机链表的复制">随机链表的复制</a></li>
                <li><a href="#排序链表">排序链表</a></li>
            </ul>
        </nav>
        <p class="article-intro">声明：本文题解所有代码都是本人编写，但由于本人能力有限，故解题思路大多参考和阅读他人文档，如果本文有侵权行为，请及时联系我删除。</p>
        <p class="article-intro">特别感谢labuladong(东哥)，本文很多思路都是参考他的文档，如果想要了解更多，请访问<a href="https://labuladong.online/algo"
                target="_blank" rel="noreferrer">labuladong的算法笔记</a>。</p>
        <p class="article-intro">本文汇总了本人刷hot100的所有题解和心得包括源代码。</p>
        <p class="article-intro">本文会持续更新，直到刷完hot100。</p>
        <section id="两数之和">
            <h1>两数之和</h1>
            <p><a href="https://leetcode.cn/problems/two-sum/" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题还是很简单的，有多种解法。</p>
            <p>解法：</p>
            <ol>
                <li>暴力解法，两层for循环，时间复杂度O(n^2)，空间复杂度O(1)</li>
                <li>哈希表，时间复杂度O(n)，空间复杂度O(n)</li>
                <li>双指针，时间复杂度O(nlogn)，空间复杂度O(1)</li>
            </ol>
            <p>针对这道题，我们可以知道，如果答案存在，那么一定会是某两个数的和，于是我们只需要针对每一个数nums[i]，都尝试在整个数组中寻找target-nums[i]，如果找到了，那么就返回这两个数的索引。</p>
            <p>于是问题就变成了，如何快速查找target-nums[i]。</p>
            <p>最直接的想法就是针对每一个数都遍历一遍数组（注意需要跳过自己），但是这样时间复杂度是O(n^2)，显然不合适。</p>
            <p>于是我们想到了哈希表，哈希表的查找时间复杂度是O(1)，所以我们可以将数组中的每一个数都存入哈希表中，然后针对每一个数nums[i]，都查找哈希表中是否存在target-nums[i]，如果存在，那么就返回这两个数的索引。
            </p>
            <p>但是我们如何在哈希表做法中跳过当前已经选择的元素呢？</p>
            <p>答案是，我们可以以每个元素为key其索引为value，每次找到了target-nums[i]的时候就检查一下索引是否和当前选择的元素的索引相同即可。这样也方便返回索引。</p>
            <p>如果你不想这么麻烦的排除重复使用一个元素的情况，那么就可以使用双指针做法。</p>
            <p>双指针做法的思路是，首先将数组排序，然后使用两个指针，一个指向数组的开头，一个指向数组的末尾，然后每次比较两个指针指向的元素的和是否等于target，如果等于，那么就返回这两个元素的索引，如果小于target，那么就移动左指针，如果大于target，那么就移动右指针。
            </p>
            <p>但是这样返回的索引是排序后的索引，而不是原数组的索引，所以需要再遍历一遍数组，找到原数组的索引。</p>
            <p>双指针做法的时间复杂度是O(nlogn)，空间复杂度是O(1)。</p>
            <p>这里给出哈希表解法的Go代码：</p>
            <pre><code>
func twoSum(nums []int, target int) []int {
    mapIndex := make(map[int]int)
    for i, v := range nums {
        mapIndex[v] = i
    }
    ans := make([]int, 2)
    for i, num := range nums {
        if anst, ok := mapIndex[target-num]; ok {
            if anst == i {
                continue
            }
            ans[0] = anst
            ans[1] = i
            break
        }
    }
    return ans
}

            </code></pre>
        </section>
        <section id="字母异位词分组">
            <h1>字母异位词分组</h1>
            <p><a href="https://leetcode.cn/problems/group-anagrams/" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>首先搞明白什么是字母异位词：字母异位词是指两个字符串，它们包含的字母相同，但是字母的顺序不同。</p>
            <p>那么如何判断两个词是字母异味词？很简单，排序！字母异位词排序后是相同的。</p>
            <p>于是这道题的思路就很清晰了，我们只需要将每个字符串排序后，然后存入哈希表中，如果哈希表中已经存在这个排序后的字符串，那么就说明这两个字符串是字母异味词，然后将这两个字符串存入同一个列表中。</p>
            <p>最后返回哈希表中的所有列表即可。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
import (
    "sort"
)

func groupAnagrams(strs []string) [][]string {
    var mapp map[string][]string
    mapp = make(map[string][]string)
    for _, str := range strs {
        chars := []rune(str)
        sort.Slice(chars, func(i, j int) bool {
            return chars[i] < chars[j]
        })
        strTemp := string(chars)
        mapp[strTemp] = append(mapp[strTemp], str)
    }
    var ans [][]string
    for _, val := range mapp {
        ans = append(ans, val)
    }
    return ans
}
            </code></pre>
        </section>
        <section id="最长连续序列">
            <h1>最长连续序列</h1>
            <p><a href="https://leetcode.cn/problems/longest-consecutive-sequence" target="_blank"
                    rel="noreferrer">题目链接</a></p>
            <p>这道题不难，但是它要求在O(n)来实现，所以我就不能简单的排序后遍历一遍，那样时间复杂度是O(nlogn)。</p>
            <p>所以思考，如何判断一个数是连续序列的一部分？很简单，如果它-1或者+1在数组中，那么它就是连续序列的一部分。</p>
            <p>于是我们可以使用一个哈希表来存储数组中的每一个数，然后遍历数组，对于每一个数，我们都检查它-1和+1是否在哈希表中，如果在，那么就说明这个数是连续序列的一部分。</p>
            <p>但是，说到这里，也只说了基础思路，在此基础上如何获得最长序列长度？</p>
            <p>想要获得最长序列长度，就要知道有序的序列起始位置在哪，起始位置有什么特点呢？那就是它-1不在数组中。</p>
            <p>所以，我们可以遍历数组，对于每一个数，我们都检查它-1是否在哈希表中，如果不在，那么就说明这个数是连续序列的起始位置。</p>
            <p>进一步我们可以从起始位置开始，向右遍历，直到遇到一个数+1不在哈希表中，那么就说明这个数是连续序列的结束位置。</p>
            <p>然后，我们就可以更新最长序列长度。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func longestConsecutive(nums []int) int {
    set := make(map[int]struct{})
    for _, num := range nums {
        set[num] = struct{}{}
    }
    ans := 0

    for num := range set {
        if _, ok := set[num-1]; ok {
            continue
        }
        ansTmp := 1
        for {
            if _, ok := set[num+1]; ok {
                num++
                ansTmp++
            } else {
                break
            }
        }
        if ansTmp > ans {
            ans = ansTmp
        }
    }
    return ans
}
            </code></pre>
            <p>这段代码中有一个需要注意的地方，那就是必须要遍历哈希表，而不是遍历数组，因为数组中可能存在重复的元素，而哈希表中不存在重复的元素，这样就可以避免重复计算，否则你会有一个测试用例过不去。</p>
        </section>
        <section id="移动零">
            <h1>移动零</h1>
            <p><a href="https://leetcode.cn/problems/move-zeroes" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题也很简单，题目要求将数组中的0移动到数组的末尾，同时保持非零元素的相对顺序。</p>
            <p>唯一需要注意的点是要保持顺序，并且不能新开数组。</p>
            <p>显而易见的一个思路：遍历数组，直到遇到0，从当前节点向后遍历数组，找到第一个非零元素，然后交换这两个元素。</p>
            <p>但是这样的时间复杂度有点高。因为你每次都遍历数组，时间复杂度是O(n^2)。</p>
            <p>于是我们可以用双指针来优化。i指向第一个为0的位置，j指向从i开始第一个非零元素的位置。</p>
            <p>先移动i，直到遇到0，然后移动j，满足j&gti&&nums[j]!=0&&j&ltlen(nums)，然后交换nums[i]和nums[j]。</p>
            <p>由于j保存了上次找到的非零元素的位置，所以j不需要每次都从i开始遍历，只需要从j开始寻找即可，所以时间消耗会少。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func moveZeroes(nums []int) {
    i, j := 0, 0
    for i < len(nums) {
        if nums[i] == 0 {
            for j < len(nums) && (j < i || nums[j] == 0) {
                j++
            }
            if j < len(nums) {
                nums[i], nums[j] = nums[j], nums[i]
            }
        }
        i++
    }
}
            </code></pre>
        </section>
        <section id="盛最多水的容器">
            <h1>盛最多水的容器</h1>
            <p><a href="https://leetcode.cn/problems/container-with-most-water" target="_blank"
                    rel="noreferrer">题目链接</a>
            </p>
            <p>这道题的目的是找到两个线段之间可以容纳的最大水量。给定一个长度为n的数组height，height[i]表示第i个线段的高度。我们可以想象成每个线段都是一个容器壁，线段之间可以容纳水。我们的目标是找到两个线段之间可以容纳的最大水量。
            </p>
            <p>这个问题的关键是如何找到这两个线段。我们可以使用双指针的方法，从两端开始向中间移动，计算每次移动时的水量，并记录最大水量。移动的策略是，如果左边的线段高度小于右边的线段高度，则移动左边的指针，反之移动右边的指针。这样可以确保每次移动都有可能找到更大的水量。
            </p>
            <p>你可能会疑惑为什么每次要移动小的那个线段指针？你可以想一下，每次的盛水容量都是由宽度和最小的线段决定的，所以如果移动大的那个线段指针，那么宽度就会减小，而最小线段的高度不会变，也就是说高度不可能变高，只可能变小，而宽度也一定减小，所以如果移动高的线段，结果一定更差。
            </p>
            <p>而如果移动的是较小的那个线段，虽然结果不一定会变大，但是至少有概率变大。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func maxArea(height []int) int {
    i, j := 0, len(height)-1
    ans := 0
    for i < j {
        width := j - i
        high := min(height[i], height[j])
        if width*high > ans {
            ans = width * high
        }
        if height[i] == high {
            i++
        } else {
            j--
        }
    }
    return ans
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
            </code></pre>
        </section>
        <section id="三数之和">
            <h1>三数之和</h1>
            <p><a href="https://leetcode.cn/problems/3sum" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题其实是二数之和的拓展。</p>
            <p>实际上这道题的做法受东哥(labuladong)启发，其思路其实是先排序，对于每一个数，都尝试在后面的数组中寻找和为0-nums[i]的二数之和，如果找到了，那么就返回这三个数。</p>
            <p>思路很简单，但是这道题的难点在于去重。本题有多个答案，并且数组中会有重复元素，所以需要在之前的二数之和的基础上进行更新：由于我们这次返回的是数字而非索引，所以我们可以大胆的使用双指针做法，并且双指针更利于去重。具体思路是，在排序好的数组中左右两个指针向中间移动，如果遇到重复元素，那么就跳过。这样就可以保证在二数和部分不会有重复内容。
            </p>
            <p>但是在三数和中还是会重复，例如这个用例：[-1,0,1,2,-1,-4]，排序后是[-4,-1,-1,0,1,2]。当选择的第一个数是-1的时候，去找和为1的二数和，得到的结果是[2,-1]和[0,1]，最终结果就是[-1,2,-1]和[-1,0,1]，但是如果后面我们选择到了2的话还是会得到[-1,2,-1]这个结果。这就重复了。
            </p>
            <p>如何解决这种重复呢？答案很简单每次找二数和的时候都只考虑当前数字后面的数组，这是因为如果整个流程按照之前的思路考虑剩下的所有数组的话，那么在选择-1的时候会考虑2，在选择2的时候会考虑-1，而2和-1同时出现的情况之前选择-1的时候就考虑过了，这就会导致重复。为了避免这种重复，我们就从当前数字的后面开始找二数和。
            </p>
            <p>这里给出Go代码：</p>
            <pre><code>
func threeSum(nums []int) [][]int {
    sort.Slice(nums, func(i, j int) bool {
        return nums[i] < nums[j]
    })
    fmt.Println(nums)
    ans := make([][]int, 0)
    for i := 0; i < len(nums); {
        numstmp := make([]int, len(nums))
        copy(numstmp, nums)
        anstwo := twoSum(numstmp[i+1:], 0-nums[i])
        for _, s := range anstwo {
            anstmp := make([]int, 3)
            anstmp[0] = nums[i]
            anstmp[1] = s[0]
            anstmp[2] = s[1]
            ans = append(ans, anstmp)
        }
        numtmp := nums[i]
        for i < len(nums) && nums[i] == numtmp {
            i++
        }
    }
    return ans
}

func twoSum(nums []int, target int) [][]int {
    ans := make([][]int, 0)
    i, j := 0, len(nums)-1
    for i < j {
        tmp := nums[i] + nums[j]
        if tmp < target {
            tmpi := nums[i]
            for i < len(nums) && nums[i] == tmpi {
                i++
            }
        } else if tmp > target {
            tmpj := nums[j]
            for j > 0 && nums[j] == tmpj {
                j--
            }
        } else {
            ansTmp := make([]int, 2)
            ansTmp[0] = nums[i]
            ansTmp[1] = nums[j]
            tmpi := nums[i]
            for i < len(nums) && nums[i] == tmpi {
                i++
            }
            tmpj := nums[j]
            for j > 0 && nums[j] == tmpj {
                j--
            }
            ans = append(ans, ansTmp)
        }
    }
    return ans
}

            </code></pre>
        </section>
        <section id="接雨水">
            <h1>接雨水</h1>
            <p><a href="https://leetcode.cn/problems/trapping-rain-water" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题是经典的接雨水问题，题目要求计算一个数组中可以接到的雨水总量。</p>
            <p>首先，如果一个地方能解雨水，是不是意味着其两边有比它高的柱子？那么一个格子能接的最大雨水量是否就是其两边最高柱子中较矮的那个减去它的高度？</p>
            <p>答案是肯定的，所以我们暴力搜索，对于每一个格子，我们都计算它两边最高的柱子，然后计算它能够接到的雨水量。</p>
            <p>但是这样时间复杂度是O(n^2)，显然不合适。</p>
            <p>于是，其实可以用一个备忘录来记录每个格子左右最高的柱子，这样时间复杂度就变成了O(n)。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func trap(height []int) int {
    lMax := make([]int, len(height))
    rMax := make([]int, len(height))
    lMax[0] = height[0]
    rMax[len(height)-1] = height[len(height)-1]
    for i := 1; i < len(height); i++ {
        lMax[i] = max(height[i], lMax[i-1])
    }
    for i := len(height) - 2; i >= 0; i-- {
        rMax[i] = max(height[i], rMax[i+1])
    }
    ans := 0
    for i := 1; i < len(height)-1; i++ {
        ans += min(lMax[i], rMax[i]) - height[i]
    }
    return ans
}

func max(a, b int) int {
    if a < b {
        return b
    }
    return a
}

func min(a, b int) int {
    if a > b {
        return b
    }
    return a
}
            </code></pre>
        </section>
        <section id="无重复字符的最长子串">
            <h1>无重复字符的最长子串</h1>
            <p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters" target="_blank"
                    rel="noreferrer">题目链接</a></p>
            <p>这道题是经典的滑动窗口问题，题目要求找到一个字符串中无重复字符的最长子串。</p>
            <p>这道题的思路是，使用一个哈希表来记录每个字符出现的次数，然后使用两个指针，一个指向当前子串的开始，一个指向当前子串的结束。</p>
            <p>右指针不断向右移动，将新的字符加入哈希表，每加入一个字符，如果哈希表中该字符的值大于1，那么就说明出现了重复字符，此时需要移动左指针，直到哈希表中该字符的值为1为止。</p>
            <p>在移动左右指针的过程中，记录当前子串的长度，并更新最大长度。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func lengthOfLongestSubstring(s string) int {
    var max int
    var windows = make(map[byte]int)
    var left, right int
    for right < len(s) {
        c := s[right]
        right++
        windows[c]++
        for windows[c] > 1 {
            d := s[left]
            left++
            windows[d]--
        }
        if right-left > max {
            max = right - left
        }
    }
    return max
}
            </code></pre>
        </section>
        <section id="找到字符串中所有字母异位词">
            <h1>找到字符串中所有字母异位词</h1>
            <p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string" target="_blank"
                    rel="noreferrer">题目链接</a></p>
            <p>这道题也是滑动窗口问题，题目要求找到一个字符串中所有字母异位词。</p>
            <p>这道题的思路是，使用两个哈希表，一个记录目标字符串p中每个字符出现的次数，一个记录当前窗口中每个字符出现的次数。</p>
            <p>然后使用两个指针，一个指向当前窗口的开始，一个指向当前窗口的结束。</p>
            <p>右指针不断向右移动，将新的字符加入窗口哈希表，如果这个字符在目标字符串p中存在，那么就将其加入窗口哈希表，并且如果窗口哈希表中该字符的值等于目标哈希表中该字符的值，那么就说明这个字符已经满足要求，将val加1。
            </p>
            <p>当窗口大小大于目标字符串p的长度时，需要移动左指针，将左指针指向的字符从窗口哈希表中移除，如果这个字符在目标字符串p中存在，那么就需要将其从窗口哈希表中移除，并且如果窗口哈希表中该字符的值等于目标哈希表中该字符的值，那么就说明这个字符不再满足要求，将val减1。
            </p>
            <p>当窗口大小等于目标字符串p的长度，并且val等于目标哈希表的大小时，说明当前窗口中的字符串是目标字符串p的字母异位词，将左指针加入答案数组。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func findAnagrams(s string, p string) []int {
    if len(s) < len(p) {
        return nil
    }
    var needp = make(map[byte]int)
    for i := 0; i < len(p); i++ {
        needp[p[i]]++
    }
    ans := make([]int, 0, len(s))
    var window = make(map[byte]int)
    var left, right, val int
    for right < len(s) {
        nowChar := s[right]
        right++
        if needp[nowChar] > 0 {
            window[nowChar]++
            if window[nowChar] == needp[nowChar] {
                val++
            }
        }
        for right-left > len(p) {
            nowChar := s[left]
            left++
            if needp[nowChar] > 0 {
                if window[nowChar] == needp[nowChar] {
                    val--
                }
                window[nowChar]--
            }
        }
        if len(p) == right-left && val == len(needp) {
            ans = append(ans, left)
        }
    }
    return ans
}
            </code></pre>
        </section>
        <section id="和为k的子数组">
            <h1>和为k的子数组</h1>
            <p><a href="https://leetcode.cn/problems/subarray-sum-equals-k" target="_blank" rel="noreferrer">题目链接</a>
            </p>
            <p>这道题在本博客的前缀和详解文章中已经详细讲解过了，这里就不再赘述。有需要的可以访问<a href="./38d932e7111444f3a6c041196932d965.html"
                    target="_blank" rel="noreferrer">前缀和详解</a>。</p>
        </section>
        <section id="滑动窗口最大值">
            <h1>滑动窗口最大值</h1>
            <p><a href="https://leetcode.cn/problems/sliding-window-maximum" target="_blank" rel="noreferrer">题目链接</a>
            </p>
            <p>这道题看似是滑动窗口题目，但是却不能用滑动窗口来做。</p>
            <p>原因很简单，在当前最大值被移出窗口的时候，你如何找到下一个最大值？难道用遍历的吗？显然不行。</p>
            <p>另外一个让人比较容易想到的解法是大顶堆，也就是优先队列，但是这也是不行的，因为窗口移动的时候被移除的元素无法映射到大顶堆里，大顶堆只能出队最大的那个元素。</p>
            <p>所以其实这道题的正确解法是单调队列。</p>
            <p>单调队列和单调栈是相对应的数据结构，单调队列的队列是双端队列，要求可以从队尾出队。</p>
            <p>单调队列的思路是，每次有新元素入队的时候，如果新元素比队尾元素大，那么就从队尾出队，直到队尾元素比新元素大为止。</p>
            <p>这样就可以保证队列是单调递减的。</p>
            <p>对应到这道题，每次移动窗口要出队的时候，如果队首元素和窗口左边界相等，那么就出队。否则忽略。入队的时候则按照单调队列的规定入队。</p>
            <p>这样就可以保证队首始终是还在窗口内的最大值。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func maxSlidingWindow(nums []int, k int) []int {
    i := 0
    j := k
    q := make([]int, 0)
    for l := i; l < j; l++ {
        for len(q) > 0 && q[len(q)-1] < nums[l] {
            q = q[:len(q)-1]
        }
        q = append(q, nums[l])
    }
    i++
    j++
    max := make([]int, 0)
    max = append(max, q[0])
    for j <= len(nums) {
        for len(q) > 0 && q[len(q)-1] < nums[j-1] {
            q = q[:len(q)-1]
        }
        q = append(q, nums[j-1])
        if q[0] == nums[i-1] {
            q = q[1:]
        }
        max = append(max, q[0])
        j++
        i++
    }
    return max
}
            </code></pre>
        </section>
        <section id="最小覆盖子串">
            <h1>最小覆盖子串</h1>
            <p><a href="https://leetcode.cn/problems/minimum-window-substring" target="_blank" rel="noreferrer">题目链接</a>
            </p>
            <p>这道题是滑动窗口问题，题目要求找到一个字符串中包含另一个字符串所有字符的最小子串。</p>
            <p>其实和<a href="#找到字符串中所有字母异位词" rel="noreferrer">找到字符串中所有字母异位词</a>思路是一样的，都是使用滑动窗口和哈希表来解决。</p>
            <p>用一个哈希表存储目标字符串t中每个字符出现的次数，用另一个哈希表存储当前窗口中每个字符出现的次数。</p>
            <p>然后使用两个指针，一个指向当前窗口的开始，一个指向当前窗口的结束。</p>
            <p>定义一个val变量来表示需要满足多少个字母的需求，当val==needval的时候说明找到了一个满足条件的子串。</p>
            <p>下面我们详细说一下滑动窗口的思路:</p>
            <p>何时移动右指针？<br>如果当前窗口内的值不能满足val==needval，那么就移动右指针，直到满足条件为止。</p>
            <p>何时移动左指针？<br>如果当前窗口内的值满足val==needval，那么就移动左指针，直到不满足条件为止。</p>
            <p>何时更新答案？<br>当val==needval的时候，并且左指针再移动一次就无法满足条件的时候，更新答案。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func minWindow(s string, t string) string {
    needMap := make(map[byte]int)
    sb := []byte(s)
    tb := []byte(t)
    needVal := 0
    for _, b := range tb {
        if _, ok := needMap[b]; !ok {
            needVal++
        }
        needMap[b]++
    }
    val := 0
    nowMap := make(map[byte]int)
    var ans string
    isAns := false
    i, j := 0, 1
    for j <= len(sb) {
        nowMap[sb[j-1]]++
        if need, ok := needMap[sb[j-1]]; ok && need == nowMap[sb[j-1]] {
            val++
        }
        for val == needVal {
            if need, ok := needMap[sb[i]]; ok && need == nowMap[sb[i]] {
                val--
                if j-i < len(ans) || !isAns {
                    ans = string(sb[i:j])
                    isAns = true
                }
            }
            nowMap[sb[i]]--
            i++
        }
        j++
    }
    return ans
}
            </code></pre>
        </section>
        <section id="最大子数组和">
            <h1>最大子数组和</h1>
            <p><a href="https://leetcode.cn/problems/maximum-subarray" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>我在<a href="./38d932e7111444f3a6c041196932d965.html" target="_blank"
                    rel="noreferrer">前缀和详解</a>中写到子数组问题大部分可以用三种算法解决：</p>
            <ol>
                <li>双指针</li>
                <li>前缀和+哈希表</li>
                <li>动态规划</li>
            </ol>
            <p>这道题是经典的动态规划问题，题目要求找到一个数组中最大的子数组和。</p>
            <p>解决动态规划问题，首先解决状态是什么。也就是dp数组是什么？</p>
            <p>一般的思维会认为dp[i]是前i个元素的最大子数组和，但是对于这道题，这样的解法是错误的，因为子数组必须连续，而“前i个元素的最大子数组和”并不一定包含第i个元素，那么如果此时通过状态转移方程，将第i+1个元素加入到dp[i]中，那么就无法保证子数组是连续的。
            </p>
            <p>那么dp[i]应该是什么呢？</p>
            <p>dp[i]应该是以第i个元素结尾的最大子数组和。</p>
            <p>那么状态转移方程是什么呢？</p>
            <p>dp[i] = max(dp[i-1]+nums[i], nums[i])</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func maxSubArray(nums []int) int {
    dp := make([]int, len(nums))
    dp[0] = nums[0]
    max := dp[0]
    for i := 1; i < len(nums); i++ {
        if dp[i-1] < 0 {
            dp[i] = nums[i]
        } else {
            dp[i] = nums[i] + dp[i-1]
        }
        if dp[i] > max {
            max = dp[i]
        }
    }
    return max
}
            </code></pre>
        </section>
        <section id="合并区间">
            <h1>合并区间</h1>
            <p><a href="https://leetcode.cn/problems/merge-intervals" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题没有什么算法，其实就是排序+模拟。</p>
            <p>首先将区间按照左节点排序，然后从第一个区间开始，判断当前区间的右节点和下一区间的左右节点的关系。</p>
            <ol>
                <li>当前右节点>=下一个区间的右节点：答案数组中直接跳过下一个区间即可。</li>
                <li>当前右节点&lt;下一个区间的右节点&&当前右节点&gt;=下一个区间的左节点：答案数组中将当前区间右节点更新为下一个区间右节点。</li>
                <li>当前右节点&lt;下一个区间的左节点：答案数组中将当前区间加入答案数组，然后更新当前区间为下一个区间。</li>
            </ol>
            <p>这里给出Go代码：</p>
            <pre><code>
import "sort"

func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    for i := 0; i < len(intervals)-1; {
        if intervals[i][1] >= intervals[i+1][1] {
            if i+2 < len(intervals) {
                intervals = append(intervals[:i+1], intervals[i+2:]...)
            } else {
                intervals = intervals[:len(intervals)-1]
            }
        } else if intervals[i][1] < intervals[i+1][1] && intervals[i][1] >= intervals[i+1][0] {
            intervals[i][1] = intervals[i+1][1]
            if i+2 < len(intervals) {
                intervals = append(intervals[:i+1], intervals[i+2:]...)
            } else {
                intervals = intervals[:len(intervals)-1]
            }
        } else {
            i++
        }
    }
    return intervals
}
            </code></pre>
            <p>熟悉Go语言的读者可以发现，这个代码的效率其实很低，因为大量使用append对切片进行删除，而Go语言中用append删除的时候其实是用后续数组覆盖前一个数组，所以很浪费时间。</p>
            <p>想详细了解Go语言特性的请移步<a href="./bf9c7b19ca5d47ddb10a5d7a7f095703.html" target="_blank"
                    rel="noreferrer">GoLang语言大揭秘</a>。</p>
            <p>这里用一个简单的示例向不熟悉Go语言的读者验证上述观点：</p>
            <pre><code>
package main

import (
    "fmt"
)

func main() {
    nums := []int{-1, -100, 3, 99}
    nums2 := append(nums[:1], nums[2:]...)
    fmt.Println(nums2)
    fmt.Println(nums)
}
            </code></pre>
            <p>输出为：</p>
            <pre><code>
[-1 3 99]
[-1 3 99 99]
            </code></pre>
            <p>可见append操作是浅拷贝，会和之前的被附加的数组共享同一个底层数组，并且其删除是覆盖删除，所以效率很低。</p>
            <p>所以这里给出优化后的代码：</p>
            <pre><code>
import "sort"

func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    res := make([][]int, 0)
    res = append(res, intervals[0])
    for i := 0; i < len(intervals); i++ {
        if res[len(res)-1][1] >= intervals[i][1] {
            continue
        } else if res[len(res)-1][1] >= intervals[i][0] && res[len(res)-1][1] < intervals[i][1] {
            res[len(res)-1][1] = intervals[i][1]
        } else {
            res = append(res, intervals[i])
        }
    }
    return res
}
            </code></pre>
            <p>这份代码使用了新的数组来存储答案，无需用append多次删除元素。</p>
        </section>
        <section id="轮转数组">
            <h1>轮转数组</h1>
            <p><a href="https://leetcode.cn/problems/rotate-array" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题是经典的数组轮转问题，题目要求将一个数组向右轮转k个位置。</p>
            <p>其实这道题一个不考虑空间复杂度的方法很简单，那就是先把k%n，然后用一个新数组存储当前数组，然后从n-k开始遍历，将新数组中的元素赋值到当前数组中。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func rotate(nums []int, k int) {
    k = k % len(nums)
    nums2 := make([]int, len(nums))
    copy(nums2, nums)
    i := len(nums) - k
    for j := 0; j < len(nums); j++ {
        nums[j] = nums2[i%len(nums)]
        i++
    }
}
            </code></pre>
            <p>奈何本人能力有限，实在没想出空间复杂度为O(1)的解法，故去查看了官方题解。</p>
            <p>实际上官方题解从数学的角度思考，对于当前数组中的nums[i]，其轮转后的位置其实是(i+k)%n，为了防止赋值后丢失位于(i+k)%n的元素，需要先保存这个元素，然后赋值，以此类推，最后总会回到nums[0]。
            </p>
            <p>但是实际上回到nums[0]的时候，整个数组中还可能有没有被遍历到的元素，所以可以用一个count存储已经遍历到的元素个数，当count==n的时候，说明整个数组已经遍历完毕，退出循环。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func rotate(nums []int, k int) {
    k = k % len(nums)
    j := 0
    count := 0
    for {
        if count == len(nums) {
            break
        }
        i := j
        tmp := nums[i]
        for {
            nums[(i+k)%len(nums)], tmp = tmp, nums[(i+k)%len(nums)]
            i = (i + k) % len(nums)
            count++
            if i == j {
                break
            }
        }
        j++
    }
}
            </code></pre>
        </section>
        <section id="除自身以外数组的乘积">
            <h1>除自身以外数组的乘积</h1>
            <p><a href="https://leetcode.cn/problems/product-of-array-except-self" target="_blank"
                    rel="noreferrer">题目链接</a></p>
            <p>这道题其实最直接的思路就是每一个都算一遍，但是这样时间复杂度是O(n^2)，显然不行。</p>
            <p>又因为这道题不让用除法，所以我们来想为什么直接的思路会很慢？答案是做了很多重复计算。</p>
            <p>那我们把重复的计算都用备忘录存下来不就好了吗？是的，这就前缀和的思想。对于这道题用到的其实是前缀乘和后缀乘。</p>
            <p>设pre[i]表示nums[0]到nums[i-1]的乘积，bef[i]表示nums[i+1]到nums[n-1]的乘积。</p>
            <p>那么答案数组ans[i]就是pre[i]*suf[i]。</p>
            <p>注意这道题无需给出整个数组的乘积，所以pre和bef数组只需要开n个元素。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func productExceptSelf(nums []int) []int {
    pre := make([]int, len(nums))
    beh := make([]int, len(nums))
    pre[0] = 1
    beh[len(beh)-1] = 1
    for i := 1; i < len(pre); i++ {
        pre[i] = pre[i-1] * nums[i-1]
    }
    for i := len(beh) - 2; i >= 0; i-- {
        beh[i] = beh[i+1] * nums[i+1]
    }
    ans := make([]int, len(nums))
    for i := 0; i < len(nums); i++ {
        ans[i] = pre[i] * beh[i]
    }
    return ans
}
            </code></pre>
        </section>
        <section id="缺失的第一个正整数">
            <h1>缺失的第一个正整数</h1>
            <p><a href="https://leetcode.cn/problems/first-missing-positive" target="_blank" rel="noreferrer">题目链接</a>
            </p>
            <p>这道题其实思路很简单。用一个哈希表存下数组中的所有值就可以了。但是题目却要求我们时间复杂度为1。</p>
            <p>题目的关键在于想清楚一件事：最终结果的大小在1到n+1之间。为什么呢？因为如果数组中的元素都是1到n的正整数，那么最终结果就是n+1。如果数组中的元素有0或者负数，那么最终结果就是1到n之间的数。是不是清晰多了？
            </p>
            <p>所以这里需要用到原地哈希。</p>
            <p>原地哈希的思路是，将数组中的元素放到其应该在的位置上。例如如果nums[i]==1，那么1应该在nums[0]的位置上。依次类推，遇到非正数或者大于n的数，则放到哪里都可以。按照这个思路排布数组，最后遍历数组，找到第一个不满足nums[i]==i+1的数，就是答案。如果所有数都满足，那么答案就是n+1。
            </p>
            <p>这里给出Go代码：</p>
            <pre><code>
func firstMissingPositive(nums []int) int {
    n := len(nums)
    for i := 0; i < len(nums); i++ {
        for j := i; nums[j] <= n && nums[j] >= 1 && nums[nums[j]-1] != nums[j]; {
            nums[nums[j]-1], nums[j] = nums[j], nums[nums[j]-1]
        }
    }
    ans := 0
    for i := 0; i < len(nums); i++ {
        if i+1 != nums[i] {
            ans = i + 1
            break
        }
    }
    if ans == 0 {
        ans = n + 1
    }
    return ans
}
            </code></pre>
        </section>
        <section id="矩阵置零">
            <h1>矩阵置零</h1>
            <p><a href="https://leetcode.cn/problems/set-matrix-zeroes" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>很简单的题目，用一个二维切片存下所有的0的位置，然后遍历这个切片，将0所在的行和列全部置零。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func setZeroes(matrix [][]int) {
    zero := make([][]int, 0)
    for i := 0; i < len(matrix); i++ {
        for j := 0; j < len(matrix[i]); j++ {
            if matrix[i][j] == 0 {
                zero = append(zero, []int{i, j})
            }
        }
    }
    for _, tmp := range zero {
        row := tmp[0]
        col := tmp[1]
        for i := 0; i < len(matrix[row]); i++ {
            matrix[row][i] = 0
        }
        for j := 0; j < len(matrix); j++ {
            matrix[j][col] = 0
        }
    }
}
            </code></pre>
        </section>
        <section id="螺旋矩阵">
            <h1>螺旋矩阵</h1>
            <p><a href="https://leetcode.cn/problems/spiral-matrix" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>其实是一个模拟题，用四个变量表示上下左右边界，然后按照顺时针方向遍历矩阵，每次遍历完一行或一列，就更新边界。</p>
            <p>具体思路就是纯粹的模拟。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func spiralOrder(matrix [][]int) []int {
    i, j := 0, 0
    n, m := len(matrix), len(matrix[0])
    ans := make([]int, n*m)
    p := 0
    length := n * m
    begin1, end1 := 0, n
    begin2, end2 := 0, m
    for p < length {
        for j := begin2; j < end2 && p < length; j++ {
            ans[p] = matrix[i][j]
            p++
        }
        j--
        i++
        for i < end1 && p < length {
            ans[p] = matrix[i][j]
            i++
            p++
        }
        i--
        j--
        for j >= begin2 && p < length {
            ans[p] = matrix[i][j]
            j--
            p++
        }
        j++
        i--
        for i >= begin1+1 && p < length {
            ans[p] = matrix[i][j]
            i--
            p++
        }
        begin1++
        begin2++
        end1--
        end2--
    }
    return ans
}
            </code></pre>
        </section>
        <section id="旋转图像">
            <h1>旋转图像</h1>
            <p><a href="https://leetcode.cn/problems/rotate-image" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题是一个很灵活的题，能想到就很简单，想不到就很难。</p>
            <p>具体思路就是先转置矩阵，然后反转每一行。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func rotate(matrix [][]int) {
    for i := 0; i < len(matrix); i++ { 
        for j :=i; j < len(matrix[i]); j++ { 
            matrix[i][j], matrix[j][i]=matrix[j][i], matrix[i][j] 
        } 
    } 
    for i :=0; i < len(matrix); i++ { 
        l :=0 
        r :=len(matrix[i]) - 1 
        for l < r { 
            matrix[i][l], matrix[i][r]=matrix[i][r], matrix[i][l] 
            l++ 
            r-- 
        } 
    } 
}
            </code></pre>
        </section>
        <section id="搜索二维矩阵II">
            <h1>搜索二维矩阵II</h1>
            <p><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii" target="_blank" rel="noreferrer">题目链接</a>
            </p>
            <p>这道题的第一思路其实是二分，但是很明显不行。</p>
            <P>所以要设计一个高效的遍历思路，因为矩阵给出了一个很好的性质，那就是从左到右，从上到下都是递增的。</P>
            <p>所以我们可以从矩阵的右上角开始遍历，如果当前元素大于target，则向左移动，如果当前元素小于target，则向下移动。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
func searchMatrix(matrix [][]int, target int) bool {
    i := 0
    j := len(matrix[0]) - 1
    for i < len(matrix) && i >= 0 && j < len(matrix[0]) && j >= 0 {
        if matrix[i][j] < target {
            i++
        } else if matrix[i][j] > target {
            j--
        } else {
            return true
        }
    }
    return false
}
            </code></pre>
        </section>
        <section id="相交链表">
            <h1>相交链表</h1>
            <p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists" target="_blank"
                    rel="noreferrer">题目链接</a></p>
            <p>这是一道技巧性的题目，可以思考一下，如果两个链表相交的话，用两个指针从两个链表的头部开始遍历，遇到nil了就从另一个链表的头部开始遍历，这样两个指针会同时到达相交节点。如果切换过一次了还没有相遇，就说明两个链表不相交。
            </p>
            <p>这里给出Go代码：</p>
            <pre><code>
/**
* Definition for singly-linked list.
* type ListNode struct {
* Val int
* Next *ListNode
* }
*/
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    var p1 *ListNode = headA
    var p2 *ListNode = headB
    p1Change := false
    p2Change := false
    for p1 != p2 {
        p1 = p1.Next
        p2 = p2.Next
        if p1 == nil {
            if !p1Change {
                p1 = headB
                p1Change = true
            } else {
                break
            }
        }
        if p2 == nil {
            if !p2Change {
                p2 = headA
                p2Change = true
            } else {
                break
            }
        }
    }
    if p1 != nil && p2 != nil {
        return p1
    }
    return nil
}
            </code></pre>
        </section>
        <section id="反转链表">
            <h1>反转链表</h1>
            <p><a href="https://leetcode.cn/problems/reverse-linked-list" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题不难，可以用多种方式解决，首先是最容易想到的最简单的思路，就是把链表节点存到数组中，然后从后往前遍历数组，组成新的链表。</p>
            <p>需要注意的是，在把链表节点存入数组的时候要断开其和其他节点的连接，否则在组成新链表的时候会报错为出现环状链表。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
/**
* Definition for singly-linked list.
* type ListNode struct {
* Val int
* Next *ListNode
* }
*/
func reverseList(head *ListNode) *ListNode {
    list:=make([]*ListNode,0)
    p:=head
    for p!=nil {
        next:=p.Next
        p.Next=nil
        list=append(list,p)
        p=next
    }
    var ans *ListNode = new(ListNode)
    p=ans
    for i:=len(list)-1;i>=0;i-- {
        p.Next=list[i]
        p=p.Next
    }
    return ans.Next
}
            </code></pre>
            <p>还可以用迭代的思路来做，每次要翻转链表的时候只需要改变链表的连接顺序，把原本是next的节点变为pre即可。所以可以通过保存前后节点的方式来把后节点的next变为当前节点，当前节点的next变为pre。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
/**
* Definition for singly-linked list.
* type ListNode struct {
* Val int
* Next *ListNode
* }
*/
func reverseList(head *ListNode) *ListNode {
    p := head
    var pre *ListNode
    var next *ListNode
    if p != nil {
        next = p.Next
    }
    for p != nil {
        p.Next = pre
        pre = p
        p = next
        if p != nil {
            next = p.Next
        }
    }
    return pre
}
            </code></pre>
        </section>
        <section id="回文链表">
            <h1>回文链表</h1>
            <p><a href="https://leetcode.cn/problems/palindrome-linked-list" target="_blank" rel="noreferrer">题目链接</a>
            </p>
            <p>这道题的思路是找到链表的中间节点，然后反转后半部分链表，最后比较前半部分和后半部分链表是否相等。但是我选择直接存到数组里，然后判断数组是否是回文。因为其实时间复杂度是一样的，都需要完全遍历一遍链表后才能进行判断。
            </p>
            <p>这里给出Go代码：</p>
            <pre><code>
/**
* Definition for singly-linked list.
* type ListNode struct {
* Val int
* Next *ListNode
* }
*/
func isPalindrome(head *ListNode) bool {
    s := make([]int, 0)
    p := head
    for p != nil {
        s = append(s, p.Val)
        p = p.Next
    }
    i, j := 0, len(s)-1
    for i <= j {
        if s[i] != s[j] {
            return false
        }
        i++
        j--
    }
    return true
}
            </code></pre>
        </section>
        <section id="环形链表">
            <h1>环形链表</h1>
            <p><a href="https://leetcode.cn/problems/linked-list-cycle" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题的思路是使用快慢指针。我们用两个指针p1和p2，初始都指向head。p1每次走一步，p2每次走两步。如果链表中存在环，那么p2一定会追上p1并相遇。因为p2比p1快，所以p2一定会先进入环，然后在环中不断追赶p1，最终相遇。
            </p>
            <p>需要注意的是，在移动指针时要检查p1、p2以及p2.Next是否为nil。因为如果链表中没有环，那么p2最终会到达链表尾部(nil)。只要遇到nil就说明一定无环，此时应该返回false。</p>
            <p>如果p1和p2相遇，说明链表中一定存在环，返回true。如果能够跳出循环，说明遇到了nil，也就是链表中不存在环，返回false。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func hasCycle(head *ListNode) bool {
    p1, p2 := head, head
    // 只要有nil就无环，无论是p1、p2还是p2的next。
    for p1 != nil && p2 != nil && p2.Next != nil {
        p1 = p1.Next
        p2 = p2.Next.Next
        if p1 == p2 {
            return true
        }
    }
    return false
}
            </code></pre>
        </section>
        <section id="环形链表II">
            <h1>环形链表II</h1>
            <p><a href="https://leetcode.cn/problems/linked-list-cycle-ii" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题是环形链表的进阶版，不仅要判断是否有环，还要找到环的入口节点。</p>
            <p>这道题的解法很巧妙，分为两步：</p>
            <ol>
                <li>第一步和环形链表I一样，使用快慢指针判断是否有环，并让两个指针在环中相遇</li>
                <li>第二步是找到环的入口。当两个指针相遇时，让p1重新指向head，然后p1和p2每次都只走一步，它们相遇的地方就是环的入口</li>
            </ol>
            <p>为什么第二步相遇的地方就是环的入口呢？这涉及到一个数学证明：</p>
            <p>假设链表头到环入口的距离为a，环入口到相遇点的距离为b，相遇点到环入口的距离为c。那么：</p>
            <ul>
                <li>p1走过的距离：a + b</li>
                <li>p2走过的距离：a + b + n(b + c)，其中n是p2在环中转的圈数</li>
                <li>由于p2速度是p1的两倍，所以：2(a + b) = a + b + n(b + c)</li>
                <li>化简得：a = c + (n-1)(b + c)</li>
            </ul>
            <p>这个等式说明：从head到环入口的距离，等于从相遇点到环入口的距离加上n-1圈。所以让p1从head开始，p2从相遇点开始，每次走一步，它们一定会在环入口相遇。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func detectCycle(head *ListNode) *ListNode {
    p1,p2:=head,head
    ifCycle:=false
    for p1!=nil&&p2!=nil&&p2.Next!=nil {
        p1=p1.Next
        p2=p2.Next.Next
        if p1==p2 {
            ifCycle=true
            break
        }
    }
    if !ifCycle {
        return nil
    }
    p1=head
    for p1!=p2 {
        p1=p1.Next
        p2=p2.Next
    }
    return p1
}
            </code></pre>
        </section>
        <section id="合并两个有序链表">
            <h1>合并两个有序链表</h1>
            <p><a href="https://leetcode.cn/problems/merge-two-sorted-lists" target="_blank" rel="noreferrer">题目链接</a>
            </p>
            <p>这道题的思路很简单，就是用两个指针分别指向两个链表，每次比较两个指针指向的节点的值，将较小的节点接到结果链表后面，然后移动对应的指针。</p>
            <p>需要注意的是，在将节点接到结果链表后面时，要先断开该节点与原链表的连接，否则会出现环状链表。</p>
            <p>最后，如果其中一个链表已经遍历完了，就把另一个链表剩余的部分直接接到结果链表后面即可。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
/**
* Definition for singly-linked list.
* type ListNode struct {
*     Val int
*     Next *ListNode
* }
*/
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    ans := new(ListNode)
    p := ans
    p1 := list1
    p2 := list2
    for p1 != nil && p2 != nil {
        if p1.Val < p2.Val {
            tmp := p1.Next
            p1.Next = nil
            p.Next = p1
            p = p.Next
            p1 = tmp
        } else {
            tmp := p2.Next
            p2.Next = nil
            p.Next = p2
            p = p.Next
            p2 = tmp
        }
    }
    if p1 != nil {
        p.Next = p1
    } else if p2 != nil {
        p.Next = p2
    }
    return ans.Next
}
        </code></pre>
        </section>
        <section id="两数相加">
            <h1>两数相加</h1>
            <p><a href="https://leetcode.cn/problems/add-two-numbers" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题是一个高精度加法的题目，两个链表分别代表两个逆序的数字，我们需要将这两个数字相加并返回结果链表。</p>
            <p>解题思路如下：</p>
            <ol>
                <li>创建一个新的链表用于存储结果</li>
                <li>同时遍历两个链表，将对应位置的数字相加</li>
                <li>需要考虑进位的情况，用一个布尔变量ifAdd记录是否需要进位</li>
                <li>当其中一个链表遍历完后，需要特殊处理进位的情况：
                    <ul>
                        <li>如果还有进位，且其中一个链表还有剩余节点，需要将剩余节点的值都加1并处理可能的连续进位</li>
                        <li>如果还有进位，但两个链表都遍历完了，需要新建一个值为1的节点</li>
                        <li>如果没有进位，直接将剩余链表接上即可</li>
                    </ul>
                </li>
            </ol>
            <p>这个解法的关键在于处理进位的传递。当出现连续的9时(比如999)，进位会导致一系列的数字变化，需要一直向后处理直到不再需要进位为止。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
/**
* Definition for singly-linked list.
* type ListNode struct {
* Val int
* Next *ListNode
* }
*/
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    ans := new(ListNode)
    p := ans
    p1 := l1
    p2 := l2
    var ifAdd bool
    for p1 != nil && p2 != nil {
        anstmp := 0
        if ifAdd {
            anstmp += 1
            ifAdd = false
        }
        tmp := p1.Val + p2.Val
        anstmp += tmp
        if anstmp/10 != 0 {
            ifAdd = true
            anstmp %= 10
        }
        p.Next = new(ListNode)
        p = p.Next
        p.Val = anstmp
        p1 = p1.Next
        p2 = p2.Next
    }
    if ifAdd {
        if p1 != nil {
            p11 := p1
            p11.Val++
            for p11.Val/10 != 0 {
                if p11.Next == nil {
                    p11.Val %= 10
                    p11.Next = new(ListNode)
                    p11.Next.Val = 1
                    break
                }
                p11.Next.Val++
                p11.Val %= 10
                p11 = p11.Next
            }
            p.Next = p1
        } else if p2 != nil {
            p22 := p2
            p22.Val++
            for p22.Val/10 != 0 {
                if p22.Next == nil {
                    p22.Val %= 10
                    p22.Next = new(ListNode)
                    p22.Next.Val = 1
                    break
                }
                p22.Next.Val++
                p22.Val %= 10
                p22 = p22.Next
            }
            p.Next = p2
        } else {
            p.Next = new(ListNode)
            p = p.Next
            p.Val = 1
        }
    } else {
        if p1 != nil {
            p.Next = p1
        } else if p2 != nil {
            p.Next = p2
        }
    }
    return ans.Next
}
            </code></pre>
        </section>
        <section id="删除链表的倒数第N个节点">
            <h1>删除链表的倒数第N个节点</h1>
            <p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list" target="_blank"
                    rel="noreferrer">题目链接</a></p>
            <p>这道题的思路是使用快慢指针。首先创建一个虚拟头节点dummy指向head，这样可以统一处理删除头节点的情况。然后用pre指向dummy，p1和p2指向head。让p2先走n步，此时p2和p1的距离就是n。然后pre、p1和p2同时向后移动，当p2到达链表尾部(nil)时，p1正好指向要删除的节点，pre指向其前一个节点。最后让pre.Next指向p1.Next完成删除操作。返回dummy.Next即为结果。
            </p>
            <p>这里给出Go代码：</p>
            <pre><code>
/**
* Definition for singly-linked list.
* type ListNode struct {
* Val int
* Next *ListNode
* }
*/
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dunny := new(ListNode)
    dunny.Next = head
    pre := dunny
    p1 := head
    p2 := head
    for i := 0; i < n; i++ {
        p2 = p2.Next
    }
    for p2 != nil {
        pre = pre.Next
        p1 = p1.Next
        p2 = p2.Next
    }
    pre.Next = p1.Next
    return dunny.Next
}
            </code></pre>
        </section>
        <section id="两两交换链表中的节点">
            <h1>两两交换链表中的节点</h1>
            <p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题的思路是先将链表节点存入一个切片中，方便后续操作。然后创建一个虚拟头节点dummy，pre指向dummy。遍历切片，每次取两个节点进行交换：将pre.Next指向第二个节点，第一个节点的Next指向第二个节点的Next，第二个节点的Next指向第一个节点，pre移动到第一个节点。如果最后只剩一个节点则不需要交换。最后返回dummy.Next即为结果。
            </p>
            <p>这里给出Go代码：</p>
            <pre><code>
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func swapPairs(head *ListNode) *ListNode {
    q := make([]*ListNode, 0)
    p := head
    for p != nil {
        q = append(q, p)
        p = p.Next
    }
    dunny := new(ListNode)
    dunny.Next = head
    pre := dunny
    for i := 0; i < len(q); i += 2 {
        if i == len(q)-1 {
            break
        }
        pre.Next = q[i+1]
        q[i].Next = q[i+1].Next
        q[i+1].Next = q[i]
        pre = q[i]
    }
    return dunny.Next
}
            </code></pre>
        </section>
        <section id="K个一组翻转链表">
            <h1>K个一组翻转链表</h1>
            <p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group" target="_blank" rel="noreferrer">题目链接</a>
            </p>
            <p>这道题的思路是先将链表节点存入一个切片中，方便后续操作。然后创建一个虚拟头节点dummy，pre指向dummy。遍历切片，每次取k个节点进行翻转：将pre.Next指向第k个节点，保存第k个节点的Next，然后从后往前依次将节点的Next指向前一个节点，最后将第一个节点的Next指向保存的next，pre移动到第一个节点。如果剩余节点数小于k则不需要翻转。最后返回dummy.Next即为结果。
            </p>
            <p>这里给出Go代码：</p>
            <pre><code>

        </section>
        <section id="随机链表的复制">
            <h1>随机链表的复制</h1>
            <p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题的思路是使用哈希表。首先遍历链表，将每个节点及其对应的随机指针存入哈希表中。然后再次遍历链表，根据哈希表中的随机指针创建新节点，并连接到新链表中。最后返回新链表的头节点。</p>
            <p>这里给出Go代码：</p>
            <pre><code>
/**
 * Definition for a Node.
 * type Node struct {
 *     Val int
 *     Next *Node
 *     Random *Node
 * }
 */

func copyRandomList(head *Node) *Node {
    hMap := make(map[*Node]*Node)
    p := head
    for p != nil {
        hMap[p] = new(Node)
        hMap[p].Val = p.Val
        p = p.Next
    }
    p = head
    for p != nil {
        hMap[p].Next = hMap[p.Next]
        hMap[p].Random = hMap[p.Random]
        p = p.Next
    }
    return hMap[head]
}
            </code></pre>
        </section>
        <section id="排序链表">
            <h1>排序链表</h1>
            <p><a href="https://leetcode.cn/problems/sort-list" target="_blank" rel="noreferrer">题目链接</a></p>
            <p>这道题的思路是使用归并排序。首先将链表分成两部分，然后对两部分分别进行排序，最后将两部分合并。（注意不能用快排，会超时！！）</p>
            <p>这里给出Go代码：</p>
            <pre><code>
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func sortList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    // 使用快慢指针找到中点
    slow, fast := head, head.Next
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }

    // 断开链表
    mid := slow.Next
    slow.Next = nil

    // 递归排序左右两半
    left := sortList(head)
    right := sortList(mid)

    // 合并有序链表
    dummy := &ListNode{Val: 0}
    curr := dummy
    for left != nil && right != nil {
        if left.Val < right.Val {
            curr.Next = left
            left = left.Next
        } else {
            curr.Next = right
            right = right.Next
        }
        curr = curr.Next
    }
    if left != nil {
        curr.Next = left
    }
    if right != nil {
        curr.Next = right
    }
    return dummy.Next
}
            </code></pre>
        </section>
    </main>
    <footer class="beian-footer">
        <div class="beian-info">
            <img src="../images/备案图标.png" alt="备案图标" class="beian-icon">
            <a href="https://beian.mps.gov.cn/#/query/webSearch?code=42011102005555" rel="noreferrer"
                target="_blank">鄂公网安备 42011102005555 </a>
            <span class="spacer"> </span>
            <a href="https://beian.miit.gov.cn/#/Integrated/index" rel="noreferrer" target="_blank"
                class="icp-beian">青ICP备2024002362号-1 </a>
        </div>
    </footer>
    <footer class="last-edit">
        <p>最后编辑时间: 2025-01-23 23:47:25</p>
    </footer>
    <script src="../js/article.js"></script>
</body>

</html>