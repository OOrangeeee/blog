<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="priority" content="normal">
    <meta name="description" content="GoLang语言大揭秘，了解GoLang的底层知识。">
    <meta name="keywords" content="GoLang, 编程, 面试, 技术分享">
    <meta name="author" content="橙子">
    <title>GoLang语言大揭秘！</title>
    <link rel="stylesheet" href="../css/article.css">
    <link rel="stylesheet" href="../css/beian.css">
    <link rel="icon" href="../images/favicon.ico" type="image/x-icon">
</head>

<body>
    <header>
        <h1>GoLang语言大揭秘！</h1>
    </header>
    <main>
        <nav>
            <h2>目录</h2>
            <ul>
                <li><a href="#why-golang">为什么选择GoLang</a></li>
                <li><a href="#is-oop">GoLang是面向对象的语言吗</a></li>
                <li><a href="#embed-vs-compose">嵌入和组合的区别</a></li>
                <li><a href="#make-vs-new">make和new的区别</a></li>
                <li><a href="#slice-vs-array">slice和array的区别</a></li>
                <li><a href="#slice-append">slice的扩容机制</a></li>
                <li><a href="#for_range_v">for range的坑</a></li>
                <li><a href="#pointers">Go语言的三种指针类型</a></li>
            </ul>
        </nav>
        <p class="article-intro">本篇文章旨在解密GoLang中的零零散散的小知识，为面试或者日常开发打下坚实的基础。</p>

        <section id="why-golang">
            <h1>为什么选择GoLang</h1>
            <p>在一切开始之前我们先来聊聊GoLang相较于其他语言的优劣势。</p>
            <table>
                <thead>
                    <tr>
                        <th>优势</th>
                        <th>劣势</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <ol>
                                <li><strong>简单易学</strong>：Go可以在很短的时间内上手开发，但了解底层机制需要一些时间。</li>
                                <li><strong>跨平台编译</strong>：结果为二进制可执行文件</li>
                                <li><strong>简洁的语法</strong>：代码风格统一</li>
                                <li><strong>天生支持高并发</strong>：Go通过Goroutine和Channel实现不同于其他语言的并发机制。<br>Channel的理论依据是CSP并发模型，即通过通信来共享内存；通过runtime运行时实现了GMP模型作为自己的调度模型，一个用户线程对应一个系统线程，同时在GMP的调度下可以将多个协程在一个用户线程中并发运行，极大的减少了用户态到内核态的切换成本。
                                </li>
                                <li><strong>行之有效的GC</strong>：Go语言最新的三色标记法+混合写屏障使得其GC效果相当不错，尽可能的减少了STW的时间。</li>
                            </ol>
                        </td>
                        <td>
                            <ol>
                                <li>“Yes and No”的面对对象编程思想，不利于实现代码的统一规范和设计模式。</li>
                                <li>缺乏一些高级特性，如：泛型编程，异常处理机制，多态等。</li>
                            </ol>
                        </td>
                    </tr>
                </tbody>
            </table>
            <p>正因上述的诸多优势，Go语言才能得到越来越多开发者的青睐。</p>
        </section>

        <section id="is-oop">
            <h1>GoLang是面向对象的语言吗</h1>
            <p>官方的QA给出的回答是yes and no。也就是说“是也不是”，因为Go不会强制要求你用面向对象来写，但是它确实可以用结构体+组合等方式实现面向对象形式的编程。</p>
            <p>为了介绍在GoLang中的面向对象编程，我们要了解面向对象的三大特性在GO中的表现：</p>
            <ol>
                <li><strong>封装</strong>：
                    Go语言实现封装和其他语言的private、public等关键字不同，Go语言通过首字母大小写来控制访问权限。首字母大写表示公有，首字母小写表示私有。而对于包级别的变量和函数，只有在同一个包内才能访问。值得注意的是结构体中的小写字段对于同一个包内是可以访问的。
                </li>
                <li><strong>继承</strong>：
                    Go语言没有继承的概念，但是可以通过结构体嵌套来实现类似继承的效果。或者也可以通过组合的方式，子结构体可以访问父结构体的字段和方法。
                </li>
                <li><strong>多态</strong>：
                    Go语言通过接口来实现多态。接口是一组方法的集合，任何类型只要实现了接口中的所有方法，就可以被视为该接口类型。这样就可以实现不同类型之间的多态性。
            </ol>
        </section>

        <section id="embed-vs-compose">
            <h1>嵌入和组合的区别</h1>
            <p>有很多人不知道嵌入和组合的区别，这里澄清一下。</p>
            <p>请看如下代码：</p>
            <pre><code>
type s1 struct {
    a int
}

type s2 struct {
    s1  // 嵌入
    b int
}

type s3 struct {
    x s1  // 组合
    c int
}
            </code></pre>
            <p>嵌入的情况下s2可以直接调用s2.a来访问对应的值，也可以调用s2.s1.a来访问a</p>
            <p>组合的情况下s3只能通过s3.x.a来访问a</p>
            <p>如果结构体有方法，那么也是同理。这些都可以用来实现继承。</p>
        </section>

        <section id="make-vs-new">
            <h1>make和new的区别</h1>
            <ol>
                <li>make用于创建slice、map、channel，new用于创建基本数据类型和结构体</li>
                <li>make返回的是引用类型，new返回的是指针类型</li>
                <li>make分配内存后会进行初始化，new分配内存后不会进行初始化而是会清零</li>
            </ol>
            <p>make和new的底层实现都是通过runtime.makemap和runtime.newobject来实现的。</p>
            <p>你可能会好奇如果用new来创建一个slice、map、channel会怎么样？</p>
            <p>答案是：会报空指针错误。除非你new完后又用make来初始化。</p>
        </section>

        <section id="slice-vs-array">
            <h1>slice和array的区别</h1>
            <ol>
                <li>
                    <p>slice是所谓的“引用类型”，而array是值类型。</p>
                    <p>实际上Go语言中没有类似于C++中的引用类型，所有的引用类型的底层其实都是指针。</p>
                    <p>slice的底层实现包含三个字段：</p>
                    <p>
                    <ul>
                        <li>array：指向底层数组的指针</li>
                        <li>len：切片的长度</li>
                        <li>cap：切片的容量</li>
                    </ul>
                    </p>
                </li>
                <li>
                    <p>slice和array的初始化方式不同。</p>
                    <p>slice的初始化方式是：</p>
                    <p>
                    <pre><code>
slice := []int{1, 2, 3}
                </code></pre>
                    </p>
                    <p>array的初始化方式是：</p>
                    <p>
                    <pre><code>
array := [3]int{1, 2, 3}
                </code></pre>
                    </p>
                    <p>区别在于数组初始化时需要指定长度，而slice不需要。并且slice可以通过make初始化，但是array则是可以用new来生成新对象。</p>
                </li>
                <li>
                    <p>slice可以动态扩容，而array不可以。</p>
                </li>
            </ol>
        </section>
        <section id="slice-append">
            <h1>slice的扩容机制</h1>
            <p>在讲述具体的扩容机制的时候我们要先定义几个概念：</p>
            <p>
            <ul>
                <li>oldcap：当前的容量</li>
                <li>newcap：最终确定的扩容目标容量</li>
                <li>wishcap：扩容的期望容量</li>
            </ul>
            </p>
            <p>扩容的逻辑如图：</p>
            <img src="../images/slice_growSlice.png" alt="slice扩容逻辑">
            <p>图中所说的最后一步的内存对齐，实际上是Go语言为了减少CPU的内存访问次数，将内存通过一定的逻辑对齐到特殊值的操作。</p>
            <p>这就是为什么有时候的实际扩容值和期望扩容值不一样。</p>
        </section>

        <section id="for_range_v">
            <h1>for range的坑</h1>
            <p>for range其实有很多坑。。。。我们一个一个展开。</p>
            <h2>临时变量</h2>
            <p>在go 1.22.0 之前for i,v :=range slice 中，i，v的地址是不会发生改变的！也就是说整个循环用到的i，v都是同一个。</p>
            <p>这就导致如果你在循环中用一个数组存储i，v的地址，那么这个数组中的所有元素的地址都是相同的。</p>
            <p>举个例子：</p>
            <pre><code>
package main
import "fmt"
func main() {
    map1 := make(map[string]int)
    map1["a"] = 1
    map1["b"] = 2
    map1["c"] = 3
    keys := make([]*string, 0, len(map1))
    values := make([]*int, 0, len(map1))
    for key, value := range map1 {
        fmt.Println(key, value)
        keys = append(keys, &key)
        values = append(values, &value)
    }
    fmt.Println(keys)
    fmt.Println(values)
}
            </code></pre>
            <p>Go 1.22.0 输出结果是：</p>
            <pre><code>
a 1
b 2
c 3
[0xc00008a030 0xc00008a050 0xc00008a070]
[0xc000096068 0xc0000960a0 0xc0000960b0]
            </code></pre>
            <p>Go 1.22.0 之前输出结果是：</p>
            <pre><code>
b 2
a 1
c 3
[0xc000010200 0xc000010200 0xc000010200]
[0xc000016070 0xc000016070 0xc000016070]
            </code></pre>
            <p>值得一提的是两次顺序不同是因为遍历map是随机顺序的。</p>
            <p>在go 1.22.0 之后，修复了这个“特性”，i，v的变量发生了改变，所以不会出现上述问题。</p>
            <p>值得注意的是不仅仅是遍历slice，map，array，channel都会出现这个问题。当然这些问题也都在Go 1.22.0 之后得到了修复。</p>
            <h2>遍历map</h2>
            <p>实际上在遍历map的时候一定是无序的，因为Go语言的map底层实现是hash表，而hash表的特性就是无序的。</p>
            <p>所以如果你需要有序的map，那么你需要使用slice来存储key，然后对slice进行排序。</p>
            <p>值得一提的是map的无序遍历实际上是go官方刻意实现的，每次遍历都会随机决定一个初始bucket，从这个桶开始遍历，每次也会随机决定一个桶内遍历的起始位置，来增加随机性。但是一次遍历中每个桶的初始遍历位置是一样的。
            </p>
            <h2>遍历slice时插入值</h2>
            <p>在遍历slice时插入值，不会导致死循环。</p>
            <p>因为每次for range的时候都会拷贝一份slice，注意不是深拷贝，而是浅拷贝。所以每次你遍历slice的时候插入值也不影响其len和cap自然不会导致死循环。</p>
            <p>举个例子：</p>
            <pre><code>
package main
import "fmt"
func main() {
    slice := []int{1, 2, 3}
    for i, v := range slice {
        slice = append(slice, i)
        fmt.Println(i, v)
    }
    fmt.Println(slice)
}
            </code></pre>
            <p>输出结果是：</p>
            <pre><code>
0 1
1 2
2 3
[1 2 3 0 1 2]
            </code></pre>
            <p>可以看出遍历的时候插入值不会造成影响。</p>
            <h2>遍历slice时改变值</h2>
            <p>在遍历slice时改变值，会影响原slice!</p>
            <p>这时因为for range做的是浅拷贝和原slice共用一个底层数组，所以改变值会影响原slice。</p>
            <p>举个例子：</p>
            <pre><code>
package main

import "fmt"

func main() {
    // 遍历的时候改变值
    slice := []int{1, 2, 3}
    for i, v := range slice {
        if i < len(slice)-1 {
            slice[i+1] = v
        }
        fmt.Println(i, v)
    }
    fmt.Println(slice)
}
            </code></pre>
            <p>输出结果是：</p>
            <pre><code>
0 1
1 1
2 1
[1 1 1]
            </code></pre>
            <p>可以看出遍历的时候改变值会影响原slice。</p>
            <h2>遍历slice时删除值</h2>
            <p>在遍历slice时删除值，会对结果有影响，但是是可以预测的。</p>
            <p>因为for range做的是浅拷贝，所以其len和cap是固定的，所以删除值会影响原slice的输出，但是不会影响输出的个数。</p>
            <p>举个例子：</p>
            <pre><code>
package main

import "fmt"

func main() {
    // 遍历的时候删除值
    slice := []int{1, 2, 3}
    for i, v := range slice {
        if i < len(slice)-1 { 
            slice=append(slice[:i+1], slice[i+2:]...) 
        }
        fmt.Println(i, v)
    }
    fmt.Println(slice)
}
            </code></pre>
            <p>输出结果是：</p>
            <pre><code>
0 1
1 3
2 3
[1 3]
            </code></pre>
            <p>可以看出遍历的时候删除值会影响原slice。</p>
            <p>之所以会输出两个3，是因为在输出0 1的时候，已经用append覆盖了2，但是临时切片的len和cap不变，所以会输出最后一个数，自然也就是是3。</p>
            <p>又一次印证，for range 生成的临时数组和原数组是共用一个底层数组的，所以改变值会影响原数组。</p>
        </section>

        <section id="pointers">
            <h1>Go语言的三种指针类型</h1>
            <p>大家都知道go语言有指针类型可以指向变量的内存地址。</p>
            <p>但是go语言有三种指针类型，分别是：</p>
            <p>
            <ul>
                <li>
                    <p>普通指针类型</p>
                </li>
                <li>
                    <p>unsafe.Pointer</p>
                </li>
                <li>
                    <p>uintptr</p>
                </li>
            </ul>
            </p>
            <p>他们有各自的区别和使用场景。</p>
            <h2>普通指针类型</h2>
            <p>普通指针类型就是我们常用的*int，*string等。</p>
            <ol>
                <li>
                    <p>用于传递对应类型对象的地址，不能进行指针运算。</p>
                </li>
                <li>
                    <p>可以访问内存的值。</p>
                </li>
                <li>
                    <p>只能在底层类型一样的指针之间进行类型转化。</p>
                </li>
                <li>
                    <p>指向的内容不会被GC回收。</p>
                </li>
            </ol>
            <p>第三点可能不好理解，举个例子：</p>
            <pre><code>
package main

import (
    "fmt"
)

type myint int

func main() {
    var a myint = 1
    ap := &a
    fmt.Println(*ap)
    var app *int
    app = (*int)(ap)
    fmt.Println(*app)
}
            </code></pre>
            <p>这段代码中ap的静态类型是*myint，app的静态类型是*int，所以虽然ap和app的底层类型都是int，但是他们的静态类型不同，必须进行类型转化后才能赋值。</p>
            <p>但是如果二者的底层类型不一样，就完全不能赋值。</p>
            <p>举个例子：</p>
            <pre><code>
package main

import (
    "fmt"
)

type myint int

func main() {
    var a myint = 1
    ap := &a
    fmt.Println(*ap)
    var app *float64
    app = (*float64)(ap)
    fmt.Println(*app)
}

            </code></pre>
            <p>这段代码会报错，因为底层类型不一样，不能进行类型转化。</p>
            <h2>unsafe.Pointer</h2>
            <p>unsafe.Pointer是go语言的通用指针类型，可以指向任何类型的内存地址。</p>
            <ol>
                <li>
                    <p>可以保存任何类型对象的地址，不能进行指针运算。</p>
                </li>
                <li>
                    <p>不能访问内存的值。</p>
                </li>
                <li>
                    <p>用于底层类型不同的指针之间的类型转化。</p>
                </li>
                <li>
                    <p>指向的内容不会被GC回收。</p>
                </li>
            </ol>
            <p>第三点其实指的是，如果你非要把两个指向完全不同底层类型的指针相互赋值的话，就需要用unsafe.Pointer来做中间桥梁。</p>
            <p>例如，上面说到的普通类型指针会报错的代码可以这样改写：</p>
            <pre><code>
package main

import (
    "fmt"
    "unsafe"
)

type myint int

func main() {
    var a myint = 1
    ap := &a
    fmt.Println(*ap)
    var app *float64
    app = (*float64)(unsafe.Pointer(ap))
    fmt.Println(*app)
}
            </code></pre>
            <p>可以看到通过unsafe.Pointer的转化就可以将一个int类型作为底层的指针赋值给float64类型的指针。</p>
            <p>请注意，其余的三个特点也非常重要，这是unsafe.Pointer与普通类型指针和uintptr的主要区别。</p>
            <h2>uintptr</h2>
            <P>很多人以为uintptr是指针，其实不然，它不过是一个uint，和指针类型的大小相等罢了，它是用来指针运算的工具。</P>
            <ol>
                <li>
                    <p>可以和unsafe.Pointer相互转化，可以进行指针运算。</p>
                </li>
                <li>
                    <p>不可以访问内存的值。</p>
                </li>
                <li>
                    <P>不算指针，自然不存在所谓的指针类型转化，它就是一个整数类型。</P>
                </li>
                <li>
                    <p>指向的内容会被GC回收。</p>
                </li>
            </ol>
            <p>所以其实uintptr就是一个和指针大小相等的整数类型。可以进行指针运算，并且不能持有对象，指向的内容会被回收。</p>
        </section>



    </main>
    <footer class="beian-footer">
        <div class="beian-info">
            <img src="../images/备案图标.png" alt="备案图标" class="beian-icon">
            <a href="https://beian.mps.gov.cn/#/query/webSearch?code=42011102005555" rel="noreferrer" target="_blank">
                鄂公网安备 42011102005555 </a>
            <span class="spacer"> </span>
            <a href="https://beian.miit.gov.cn/#/Integrated/index" rel="noreferrer" target="_blank" class="icp-beian">
                青ICP备2024002362号-1 </a>
        </div>
    </footer>
    <footer class="last-edit">
        <p>最后编辑时间: 2025-01-12 12:24:54</p>
    </footer>
    <script src="../js/article.js"></script>
</body>

</html>